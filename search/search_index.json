{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Markdown to Confluence (md-to-conf) Documentation","text":""},{"location":"#about-the-project","title":"About The Project","text":"<p><code>md-to-conf</code> is a Python module for publishing Markdown files to Confluence.</p>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#markdown-support","title":"Markdown Support","text":"<ul> <li>Markdown Syntax Guide - Comprehensive documentation of all supported markdown features</li> <li>Quick Reference - Quick reference for special syntax and features  </li> <li>Examples - Complete examples demonstrating all features</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Client Reference - Confluence API client documentation</li> <li>Converter Reference - Markdown converter documentation</li> <li>Main Reference - Main module documentation</li> </ul>"},{"location":"#user-guides","title":"User Guides","text":"<ul> <li>Getting Started - Installation and basic usage</li> <li>Contributing - How to contribute to the project</li> </ul>"},{"location":"#built-with","title":"Built With","text":"<ul> <li>Python</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":""},{"location":"CHANGELOG/#added","title":"Added","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":""},{"location":"CHANGELOG/#111-2025-10-18","title":"[1.1.1] - 2025-10-18","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Updated attachment handling to use Confluence REST API v2 endpoints consistently</li> <li>Improved error handling in get_attachment method with proper 404 response handling</li> <li>Enhanced attachment filename URL encoding for better compatibility</li> <li>Updated API client documentation and parameter descriptions</li> </ul>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Comprehensive test coverage for converter.py edge cases (code blocks without language, generic blockquotes)</li> <li>Additional test coverage for client.py error scenarios (delete page failures, attachment not found cases)</li> <li>Improved test infrastructure using proper mocking patterns with check_errors_and_get_json</li> </ul>"},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Attachment upload/download endpoints now properly use v2 API paths</li> <li>Better error logging and diagnostics for attachment operations</li> </ul>"},{"location":"CHANGELOG/#110-2025-10-18","title":"[1.1.0] - 2025-10-18","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Support for GitHub-flavored markdown alert boxes ([!NOTE], [!TIP], [!IMPORTANT], [!WARNING], [!CAUTION])</li> <li>Comprehensive test coverage for GitHub alerts functionality</li> <li>Documentation for GitHub alerts in markdown syntax guide</li> <li>ADF panel format support for IMPORTANT alerts</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Refactored GitHub alerts processing to reduce cognitive complexity</li> <li>Fixed ReDoS vulnerability in alert processing regex patterns</li> <li>Improved type annotations with Optional types for better code safety</li> <li>Updated documentation with GitHub alerts examples and usage</li> </ul>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Security vulnerability (SonarQube S5852) in regex patterns</li> <li>Type annotation warnings (SonarQube S5886) for functions returning None</li> <li>Code formatting and linting issues (flake8, black)</li> </ul>"},{"location":"CHANGELOG/#1014-2025-10-17","title":"[1.0.14] - 2025-10-17","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Folder ancestor support for page organization</li> </ul>"},{"location":"CHANGELOG/#1013-2025-10-17","title":"[1.0.13] - 2025-10-17","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Support for additional block types (Success and Error panels)</li> <li>Enhanced panel macro support with more visual indicators</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Updated documentation with new block type examples</li> <li>Improved macro images in documentation</li> </ul>"},{"location":"CHANGELOG/#1012-2025-10-17","title":"[1.0.12] - 2025-10-17","text":""},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Link replacement functionality for better internal linking</li> </ul>"},{"location":"CHANGELOG/#1011-2025-10-16","title":"[1.0.11] - 2025-10-16","text":""},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Unnecessary version metadata from editor processing</li> </ul>"},{"location":"CHANGELOG/#1010-2025-10-01","title":"[1.0.10] - 2025-10-01","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Updated package requirements and dependencies</li> </ul>"},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>GitHub Actions build process</li> </ul>"},{"location":"CHANGELOG/#109-2024-02-01","title":"[1.0.9] - 2024-02-01","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Conversion functionality broken out into separate class for better modularity</li> </ul>"},{"location":"CHANGELOG/#fixed_5","title":"Fixed","text":"<ul> <li>Issue with adding labels that do not exist yet</li> <li>Empty labels handling</li> </ul>"},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>GitHub Actions to build fix branches</li> <li>Code formatting improvements</li> </ul>"},{"location":"CHANGELOG/#108-2024-01-30","title":"[1.0.8] - 2024-01-30","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li>Extension for proper list handling (mdx_truly_sane_lists)</li> </ul>"},{"location":"CHANGELOG/#fixed_6","title":"Fixed","text":"<ul> <li>List conversion issues in markdown processing</li> <li>Missing requirement in setup.py</li> </ul>"},{"location":"CHANGELOG/#107-2024-01-29","title":"[1.0.7] - 2024-01-29","text":""},{"location":"CHANGELOG/#fixed_7","title":"Fixed","text":"<ul> <li>Organization name validation in API client</li> </ul>"},{"location":"CHANGELOG/#106-2024-01-29","title":"[1.0.6] - 2024-01-29","text":""},{"location":"CHANGELOG/#fixed_8","title":"Fixed","text":"<ul> <li>Module initialization and import issues</li> <li>SonarQube code quality issues</li> <li>Linting warnings and formatting</li> </ul>"},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Updated GitHub Actions workflow steps</li> <li>Improved module structure</li> </ul>"},{"location":"CHANGELOG/#105-2023-08-14","title":"[1.0.5] - 2023-08-14","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li>Change Log</li> </ul>"},{"location":"CHANGELOG/#104-2023-08-14","title":"[1.0.4] - 2023-08-14","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li>Documentation via mkdocs, including a documentation publish pipeline</li> </ul>"},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Added an <code>r</code> (raw) designation to Regex strings.</li> <li>Updated docstrings to Google style.</li> </ul>"},{"location":"CHANGELOG/#103-2023-08-11","title":"[1.0.3] - 2023-08-11","text":""},{"location":"CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Reverted Sonar suggestions to fix bug with TOC</li> </ul>"},{"location":"CHANGELOG/#102-2023-08-10","title":"[1.0.2] - 2023-08-10","text":""},{"location":"CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Reduced complexity on some functions</li> <li>Applied Black/Flake8 formatting across files</li> </ul>"},{"location":"CHANGELOG/#101-2023-08-10","title":"[1.0.1] - 2023-08-10","text":""},{"location":"CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li>Fixed PyPi packaging to properly version the published wheel</li> </ul>"},{"location":"CHANGELOG/#100-2023-08-10","title":"[1.0.0] - 2023-08-10","text":""},{"location":"CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li>Completed migration from RittmanMead/md_to_conf with packaging and PyPi publishing</li> </ul>"},{"location":"contributing/","title":"Contribution Guidelines","text":""},{"location":"contributing/#environment-configuration","title":"Environment Configuration","text":"<p>It is recommended that you use a virtual environment for development.</p>"},{"location":"contributing/#venv","title":"VENV","text":"<p>Create a new python virtualenv and activate it:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"contributing/#anaconda","title":"Anaconda","text":"<p>Installation Guide</p> <pre><code>  conda create --name md_to_conf python=3.11 --yes\n  conda activate md_to_conf\n</code></pre>"},{"location":"contributing/#requirements","title":"Requirements","text":"<p>Install the requirements for the application:</p> <pre><code>pip install -r requirements.txt\npip install -r requirements-dev.txt\n</code></pre>"},{"location":"contributing/#install-the-module","title":"Install the Module","text":"<p>Install the module in an editable mode:</p> <pre><code>pip install -e .\n</code></pre> <p>Run <code>md-to-conf -h</code> and verify that the help is displayed.</p>"},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are what make the open source community such an amazing place to be learn, inspire, and create. Any contributions you make are greatly appreciated.</p> <ol> <li>Fork the Project</li> <li>Create your Feature Branch (<code>git checkout -b feature/AmazingFeature</code>)</li> <li>Commit your Changes (<code>git commit -m 'Add some AmazingFeature'</code>)</li> <li>Push to the Branch (<code>git push origin feature/AmazingFeature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"contributing/#formatting-and-linting","title":"Formatting and Linting","text":"<p>This repository is configured to use pre-commit to check code, including Black and Flake8 to format and lint code.  It is always good to format before commiting changes.</p> <p>To format:</p> <pre><code>&gt; black .\n</code></pre> <p>To execute flake8 across your changes</p> <pre><code>&gt; flake8 .\n</code></pre> <p>To check your files before committing:</p> <pre><code>&gt; pre-commit run\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p><code>tox</code> is used to setup tests and linting.  It can be used to run tests locally.</p> <pre><code># Install tox\npython -m pip install --upgrade tox\n\n#run tests\ntox run -e py311\n\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>This repository uses mkdocs to generate the documentation site, along with mkdocsstrings-python to extract documentation from code comments.  This project uses Google-formatted docstrings to generate, so please follow that standard when documenting code.</p> <p>Your contribution should be documented.  You can generate documentation locally using the following commands.</p> <pre><code>&gt; pip install -r requirements-mkdocs.txt\n&gt; mkdocs serve\n</code></pre> <p>The documentation site is updated when new releases are published in Github.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>PIP</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install this tool using <code>pip</code>:</p> <pre><code>pip install md-to-conf\n</code></pre>"},{"location":"getting-started/#usage","title":"Usage","text":""},{"location":"getting-started/#basic","title":"Basic","text":"<p>The minimum accepted parameters are the markdown file to upload as well as the Confluence space key you wish to upload to. For the following examples assume 'Test Space' with key: <code>TST</code>.</p> <pre><code>python3 md2conf.py readme.md TST\n</code></pre> <p>Mandatory Confluence parameters can also be set here if not already set as environment variables:</p> <ul> <li>-u --username: Confluence User</li> <li>-p --apikey: Confluence API Key</li> <li>-o --orgname: Confluence Organization</li> </ul> <pre><code>python3 md2conf.py readme.md TST -u basil -p abc123 -o fawltytowers\n</code></pre> <p>Use -h to view a list of all available options.</p>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<p>To use it, you will need your Confluence username, API key and organization name. To generate an API key go to https://id.atlassian.com/manage/api-tokens.</p> <p>You will also need the organization name that is used in the subdomain. For example the URL: <code>https://fawltytowers.atlassian.net/wiki/</code> would indicate an organization name of fawltytowers.</p> <p>If the organization name contains a dot, it will be considered as a Fully Qualified Domain Name. For example the URL: <code>https://fawltytowers.mydomain.com/</code> would indicate an organization name of fawltytowers.mydomain.com.</p> <p>These can be specified at runtime or set as Confluence environment variables (e.g. add to your <code>~/.profile</code> or <code>~/.bash_profile</code> on Mac OS):</p> <pre><code>export CONFLUENCE_USERNAME='basil'\nexport CONFLUENCE_API_KEY='abc123'\nexport CONFLUENCE_ORGNAME='fawltytowers'\n</code></pre> <p>On Windows, this can be set via system properties.</p>"},{"location":"getting-started/#other-uses","title":"Other Uses","text":"<p>Use -a or --ancestor to designate the name of a page which the page should be created under.</p> <pre><code>python md2conf.py readme.md TST -a \"Parent Page Name\"\n</code></pre> <p>Use -d or --delete to delete the page instead of create it. Obviously this won't work if it doesn't already exist.</p> <p>Use -n or --nossl to specify a non-SSL url, i.e. http:// instead of https://.</p> <p>Use -l or --loglevel to specify a different logging level, i.e DEBUG.</p> <p>Use -s or --simulate to stop processing before interacting with confluence API, i.e. only  converting the markdown document to confluence format.</p> <p>Use --title to set the title for the page, otherwise the title is going to be the first line in the markdown file</p> <p>Use --remove-emojies to emove emojies if there are any. This may be need if the database doesn't support emojies</p>"},{"location":"getting-started/#markdown","title":"Markdown","text":"<p>The original markdown to HTML conversion is performed by the Python markdown library. Additionally, the page name is taken from the first line of  the markdown file, usually assumed to be the title. In the case of this document, the page would be called: Markdown to Confluence Converter.</p> <p>Standard markdown syntax for images and code blocks will be automatically converted. The images are uploaded as attachments and the references updated in the HTML. The code blocks will be converted to the Confluence Code Block macro and also supports syntax highlighting.</p>"},{"location":"getting-started/#doctoc","title":"Doctoc","text":"<p>If present, what is between the doctoc anchor format:</p> <pre><code>&lt;!-- START doctoc ...\n...\n... END doctoc --&gt;\n</code></pre> <p>will be replaced by confluence \"toc\" macro leading to something like:</p> <pre><code>&lt;h2&gt;Table of Content&lt;/h2&gt;\n&lt;p&gt;\n    &lt;ac:structured-macro ac:name=\"toc\"&gt;\n      &lt;ac:parameter ac:name=\"printable\"&gt;true&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"maxLevel\"&gt;7&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"outline\"&gt;clear&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"include\"&gt;.*&lt;/ac:parameter&gt;\n    &lt;/ac:structured-macro&gt;\n    &lt;/p&gt;\n</code></pre>"},{"location":"getting-started/#information-note-and-warning-macros","title":"Information, Note and Warning Macros","text":"<p>Warning: Any blockquotes used will implement an information macro. This could potentially harm your formatting.</p> <p>Block quotes in Markdown are rendered as information macros.</p> <pre><code>&gt; This is an info\n</code></pre> <p></p> <pre><code>&gt; Note: This is a note\n</code></pre> <p></p> <pre><code>&gt; Success: This is a success\n</code></pre> <p></p> <pre><code>&gt; Warning: This is a warning\n</code></pre> <p></p> <pre><code>&gt; Error: This is an error\n</code></pre> <p></p> <p>Alternatively, using a custom Markdown syntax also works:</p> <pre><code>~?This is an info.?~\n\n~%This is a warning.%~\n\n~^This is a success.^~\n\n~$This is an error.$~\n\n~!This is a note.!~\n</code></pre>"},{"location":"markdown-examples/","title":"Markdown Examples for md_to_conf","text":"<p>This file demonstrates all the markdown features supported by the md_to_conf converter.</p>"},{"location":"markdown-examples/#standard-markdown-features","title":"Standard Markdown Features","text":""},{"location":"markdown-examples/#headers","title":"Headers","text":""},{"location":"markdown-examples/#header-1","title":"Header 1","text":""},{"location":"markdown-examples/#header-2","title":"Header 2","text":""},{"location":"markdown-examples/#header-3","title":"Header 3","text":""},{"location":"markdown-examples/#header-4","title":"Header 4","text":""},{"location":"markdown-examples/#header-5","title":"Header 5","text":""},{"location":"markdown-examples/#header-6","title":"Header 6","text":""},{"location":"markdown-examples/#text-formatting","title":"Text Formatting","text":"<p>This is bold text and this is italic text. You can also use bold and italic together. ~~Strikethrough~~ text is also supported. Don't forget <code>inline code</code> formatting.</p>"},{"location":"markdown-examples/#lists","title":"Lists","text":""},{"location":"markdown-examples/#unordered-lists","title":"Unordered Lists","text":"<ul> <li>First item</li> <li>Second item</li> <li>Nested item 2.1</li> <li>Nested item 2.2<ul> <li>Deep nested item</li> </ul> </li> <li>Third item</li> </ul>"},{"location":"markdown-examples/#ordered-lists","title":"Ordered Lists","text":"<ol> <li>First numbered item</li> <li>Second numbered item</li> <li>Nested numbered item 2.1</li> <li>Nested numbered item 2.2<ol> <li>Deep nested numbered item</li> </ol> </li> <li>Third numbered item</li> </ol>"},{"location":"markdown-examples/#tables","title":"Tables","text":"Feature Supported Notes Headers \u2713 All 6 levels Bold/Italic \u2713 Standard markdown Lists \u2713 Including nested Tables \u2713 Full table support Links \u2713 Internal and external"},{"location":"markdown-examples/#links-and-references","title":"Links and References","text":"<p>External link Link with title Internal link to header</p>"},{"location":"markdown-examples/#special-confluence-features","title":"Special Confluence Features","text":""},{"location":"markdown-examples/#github-flavored-markdown-alerts-recommended","title":"GitHub-Flavored Markdown Alerts (Recommended)","text":""},{"location":"markdown-examples/#note-alert-info-panel","title":"Note Alert (Info Panel)","text":"<p>[!NOTE] This is a note alert that will appear in a blue info panel.</p>"},{"location":"markdown-examples/#tip-alert-tip-panel","title":"Tip Alert (Tip Panel)","text":"<p>[!TIP] This is a tip alert that will appear in a green tip panel.</p>"},{"location":"markdown-examples/#important-alert-special-adf-panel","title":"Important Alert (Special ADF Panel)","text":"<p>[!IMPORTANT] This is an important alert that will appear in a special ADF note panel format for better visibility.</p>"},{"location":"markdown-examples/#warning-alert-warning-panel","title":"Warning Alert (Warning Panel)","text":"<p>[!WARNING] This is a warning alert that will appear in a yellow warning panel.</p>"},{"location":"markdown-examples/#caution-alert-error-panel","title":"Caution Alert (Error Panel)","text":"<p>[!CAUTION] This is a caution alert that will appear in a red error panel.</p>"},{"location":"markdown-examples/#status-panels-via-blockquotes","title":"Status Panels via Blockquotes","text":""},{"location":"markdown-examples/#info-panel-default","title":"Info Panel (Default)","text":"<p>This is general information that will appear in a blue info panel.</p>"},{"location":"markdown-examples/#warning-panel","title":"Warning Panel","text":"<p>Warning: This is a warning message that will appear in a yellow warning panel.</p>"},{"location":"markdown-examples/#success-panel","title":"Success Panel","text":"<p>Success: This is a success message that will appear in a green success panel.</p>"},{"location":"markdown-examples/#error-panel","title":"Error Panel","text":"<p>Error: This is an error message that will appear in a red error panel.</p>"},{"location":"markdown-examples/#note-panel","title":"Note Panel","text":"<p>Note: This is a note that will appear in a special note panel format.</p>"},{"location":"markdown-examples/#custom-panel-syntax","title":"Custom Panel Syntax","text":""},{"location":"markdown-examples/#info-panel","title":"Info Panel","text":"<p>~?This is an info panel using the custom tilde syntax.?~</p>"},{"location":"markdown-examples/#warning-panel_1","title":"Warning Panel","text":"<p>~%This is a warning panel using the custom tilde syntax.%~</p>"},{"location":"markdown-examples/#success-panel_1","title":"Success Panel","text":"<p>~^This is a success panel using the custom tilde syntax.^~</p>"},{"location":"markdown-examples/#error-panel_1","title":"Error Panel","text":"<p>~$This is an error panel using the custom tilde syntax.$~</p>"},{"location":"markdown-examples/#note-panel_1","title":"Note Panel","text":"<p>~!This is a note panel using the custom tilde syntax.!~</p>"},{"location":"markdown-examples/#table-of-contents","title":"Table of Contents","text":""},{"location":"markdown-examples/#simple-toc","title":"Simple TOC","text":"<ul> <li>Markdown Examples for md_to_conf<ul> <li>Standard Markdown Features<ul> <li>Headers</li> </ul> </li> </ul> </li> <li>Header 1<ul> <li>Header 2<ul> <li>Header 3<ul> <li>Header 4<ul> <li>Header 5<ul> <li>Header 6</li> </ul> </li> </ul> </li> </ul> </li> <li>Text Formatting</li> <li>Lists<ul> <li>Unordered Lists</li> <li>Ordered Lists</li> </ul> </li> <li>Tables</li> <li>Links and References</li> </ul> </li> <li>Special Confluence Features<ul> <li>GitHub-Flavored Markdown Alerts (Recommended)<ul> <li>Note Alert (Info Panel)</li> <li>Tip Alert (Tip Panel)</li> <li>Important Alert (Special ADF Panel)</li> <li>Warning Alert (Warning Panel)</li> <li>Caution Alert (Error Panel)</li> </ul> </li> <li>Status Panels via Blockquotes<ul> <li>Info Panel (Default)</li> <li>Warning Panel</li> <li>Success Panel</li> <li>Error Panel</li> <li>Note Panel</li> </ul> </li> <li>Custom Panel Syntax<ul> <li>Info Panel</li> <li>Warning Panel</li> <li>Success Panel</li> <li>Error Panel</li> <li>Note Panel</li> </ul> </li> </ul> </li> <li>Table of Contents<ul> <li>Simple TOC</li> <li>DocToc Example</li> </ul> </li> <li>Code Examples<ul> <li>JavaScript Code Block</li> <li>Python Code Block</li> <li>SQL Code Block</li> <li>Generic Code Block (No Language)</li> </ul> </li> <li>Comments and Hidden Content<ul> <li>HTML Comments</li> </ul> </li> <li>Footnotes and References</li> <li>Images and Attachments<ul> <li>Local Images (Auto-uploaded)</li> <li>External Images (URLs preserved)</li> </ul> </li> <li>Advanced Internal Linking</li> <li>Emoji Examples</li> <li>Command Line Usage Examples<ul> <li>Basic Conversion</li> <li>With Table of Contents</li> <li>Remove Emojis and Add Custom Title</li> <li>With Labels and Properties</li> <li>With Attachments</li> <li>Bitbucket Source Format</li> <li>Simulation Mode (Preview Only)</li> </ul> </li> <li>Processing Notes<ul> <li>Order of Operations</li> <li>Limitations</li> </ul> </li> </ul> </li> </ul>"},{"location":"markdown-examples/#doctoc-example","title":"DocToc Example","text":"<p>Table of Contents</p> <ul> <li>Header 1</li> <li>Header 2</li> </ul>"},{"location":"markdown-examples/#code-examples","title":"Code Examples","text":""},{"location":"markdown-examples/#javascript-code-block","title":"JavaScript Code Block","text":"<pre><code>function greetUser(name) {\n    console.log(`Hello, ${name}!`);\n    return true;\n}\n\n// Call the function\ngreetUser(\"World\");\n</code></pre>"},{"location":"markdown-examples/#python-code-block","title":"Python Code Block","text":"<pre><code>def calculate_fibonacci(n):\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    if n &lt;= 1:\n        return n\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)\n\n# Example usage\nresult = calculate_fibonacci(10)\nprint(f\"The 10th Fibonacci number is: {result}\")\n</code></pre>"},{"location":"markdown-examples/#sql-code-block","title":"SQL Code Block","text":"<pre><code>SELECT \n    users.name,\n    users.email,\n    COUNT(orders.id) as order_count\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id\nWHERE users.active = 1\nGROUP BY users.id, users.name, users.email\nORDER BY order_count DESC;\n</code></pre>"},{"location":"markdown-examples/#generic-code-block-no-language","title":"Generic Code Block (No Language)","text":"<pre><code>This is a generic code block without a specific language.\nIt will still be formatted with the Midnight theme and line numbers.\n\nfunction example() {\n    return \"No syntax highlighting\";\n}\n</code></pre>"},{"location":"markdown-examples/#comments-and-hidden-content","title":"Comments and Hidden Content","text":""},{"location":"markdown-examples/#html-comments","title":"HTML Comments","text":"<p>These comments won't be visible in the final Confluence page but can be seen in the editor.</p>"},{"location":"markdown-examples/#footnotes-and-references","title":"Footnotes and References","text":"<p>This text has a footnote reference[^1].</p> <p>Here's another reference to a different footnote[^2].</p> <p>You can also reference the same footnote multiple times[^1].</p> <p>[^1]: This is the first footnote with a link to example.com. [^2]: This is the second footnote with bold text and italic text.</p>"},{"location":"markdown-examples/#images-and-attachments","title":"Images and Attachments","text":""},{"location":"markdown-examples/#local-images-auto-uploaded","title":"Local Images (Auto-uploaded)","text":""},{"location":"markdown-examples/#external-images-urls-preserved","title":"External Images (URLs preserved)","text":""},{"location":"markdown-examples/#advanced-internal-linking","title":"Advanced Internal Linking","text":"<p>This section demonstrates internal linking to other headers:</p> <ul> <li>Link to Headers section</li> <li>Link to Code Examples</li> <li>Link to Status Panels</li> <li>Link to Table of Contents section</li> </ul>"},{"location":"markdown-examples/#emoji-examples","title":"Emoji Examples","text":"<p>Here are some emojis that can be removed with the <code>--remove-emojies</code> option:</p> <p>\ud83d\ude00 \ud83d\ude03 \ud83d\ude04 \ud83d\ude01 \ud83d\ude06 \ud83d\ude05 \ud83d\ude02 \ud83e\udd23 \ud83d\ude0a \ud83d\ude07 \ud83e\udd70 \ud83d\ude0d \ud83e\udd29 \ud83d\ude18 \ud83d\ude17 \u263a\ufe0f \ud83d\ude1a \ud83d\ude19 \ud83e\udd72 \ud83d\ude0b \ud83d\udc4d \ud83d\udc4e \ud83d\udc4f \ud83d\ude4c \ud83d\udc50 \ud83e\udd32 \ud83e\udd1d \ud83d\ude4f \u270d\ufe0f \ud83d\udcaa \ud83d\ude80 \ud83d\udef8 \ud83c\udf1f \u2b50 \ud83d\udcab \u26a1 \ud83d\udd25 \ud83d\udca5 \ud83d\udca8 \ud83d\udca6 \ud83c\uddfa\ud83c\uddf8 \ud83c\uddec\ud83c\udde7 \ud83c\uddeb\ud83c\uddf7 \ud83c\udde9\ud83c\uddea \ud83c\uddee\ud83c\uddf9 \ud83c\uddea\ud83c\uddf8 \ud83c\uddef\ud83c\uddf5 \ud83c\udde8\ud83c\uddf3 \ud83c\uddf0\ud83c\uddf7 \ud83c\uddee\ud83c\uddf3</p>"},{"location":"markdown-examples/#command-line-usage-examples","title":"Command Line Usage Examples","text":""},{"location":"markdown-examples/#basic-conversion","title":"Basic Conversion","text":"<pre><code>md_to_conf example.md SPACEKEY -u username -p apikey -o orgname\n</code></pre>"},{"location":"markdown-examples/#with-table-of-contents","title":"With Table of Contents","text":"<pre><code>md_to_conf example.md SPACEKEY -u username -p apikey -o orgname --contents\n</code></pre>"},{"location":"markdown-examples/#remove-emojis-and-add-custom-title","title":"Remove Emojis and Add Custom Title","text":"<pre><code>md_to_conf example.md SPACEKEY -u username -p apikey -o orgname \\\n  --remove-emojies --title \"Custom Page Title\"\n</code></pre>"},{"location":"markdown-examples/#with-labels-and-properties","title":"With Labels and Properties","text":"<pre><code>md_to_conf example.md SPACEKEY -u username -p apikey -o orgname \\\n  --label \"documentation\" --label \"markdown\" \\\n  --property \"team=engineering\" --property \"version=1.0\"\n</code></pre>"},{"location":"markdown-examples/#with-attachments","title":"With Attachments","text":"<pre><code>md_to_conf example.md SPACEKEY -u username -p apikey -o orgname \\\n  --attachment \"diagrams/architecture.png\" --attachment \"files/config.json\"\n</code></pre>"},{"location":"markdown-examples/#bitbucket-source-format","title":"Bitbucket Source Format","text":"<pre><code>md_to_conf example.md SPACEKEY -u username -p apikey -o orgname \\\n  --markdownsrc bitbucket\n</code></pre>"},{"location":"markdown-examples/#simulation-mode-preview-only","title":"Simulation Mode (Preview Only)","text":"<pre><code>md_to_conf example.md SPACEKEY -u username -p apikey -o orgname --simulate\n</code></pre>"},{"location":"markdown-examples/#processing-notes","title":"Processing Notes","text":""},{"location":"markdown-examples/#order-of-operations","title":"Order of Operations","text":"<ol> <li>Markdown \u2192 HTML conversion</li> <li>Title processing</li> <li>Table of contents generation</li> <li>Panel/macro conversion</li> <li>Comment processing</li> <li>Code block formatting</li> <li>Emoji removal (if enabled)</li> <li>Contents addition (if enabled)</li> <li>Reference processing</li> <li>Internal link processing</li> </ol>"},{"location":"markdown-examples/#limitations","title":"Limitations","text":"<ul> <li>Internal links only work within the same page</li> <li>External image URLs are not uploaded as attachments</li> <li>Panel type detection requires specific keywords</li> <li>Nested list indentation must be consistent (2+ spaces)</li> <li>Code language detection depends on fence specification</li> </ul> <p>This example file demonstrates all the supported markdown features. Copy sections as needed for your own documentation!</p>"},{"location":"markdown-quick-reference/","title":"Markdown Quick Reference","text":"<p>Quick reference for special markdown syntax supported by md_to_conf converter.</p>"},{"location":"markdown-quick-reference/#status-panels","title":"Status Panels","text":""},{"location":"markdown-quick-reference/#github-flavored-markdown-alerts-recommended","title":"GitHub-Flavored Markdown Alerts (Recommended)","text":"<pre><code>&gt; [!NOTE]      # Info panel (blue icon)\n&gt; [!TIP]       # Tip panel (green icon)\n&gt; [!IMPORTANT] # Important panel (special ADF format)\n&gt; [!WARNING]   # Warning panel (yellow caution icon)\n&gt; [!CAUTION]   # Error panel (red cross icon)\n</code></pre>"},{"location":"markdown-quick-reference/#blockquote-style","title":"Blockquote Style","text":"<pre><code>&gt; This is general info (blue icon)\n&gt; Warning: This is a warning (yellow caution icon)  \n&gt; Success: This is success (green check icon)\n&gt; Error: This is an error (red cross icon)\n&gt; Note: This is a note (special ADF format)\n</code></pre>"},{"location":"markdown-quick-reference/#custom-tilde-style","title":"Custom Tilde Style","text":"<pre><code>~?Info panel?~\n~%Warning panel%~\n~^Success panel^~\n~$Error panel$~\n~!Note panel!~\n</code></pre>"},{"location":"markdown-quick-reference/#table-of-contents","title":"Table of Contents","text":"<pre><code>[TOC]                           # Simple TOC\n--add-contents flag             # Auto-add comprehensive TOC\n&lt;!-- START doctoc ... --&gt;       # DocToc integration\n</code></pre>"},{"location":"markdown-quick-reference/#code-blocks","title":"Code Blocks","text":"<pre><code>```javascript\n// Language-specific code block\nfunction example() { return true; }\n```\n\n```\n// Generic code block (no language)\n```\n</code></pre> <p>Features: Midnight theme, line numbers enabled, language detection</p>"},{"location":"markdown-quick-reference/#comments","title":"Comments","text":"<pre><code>&lt;!-- Hidden comment in Confluence --&gt;\n</code></pre>"},{"location":"markdown-quick-reference/#internal-links","title":"Internal Links","text":"<pre><code>[Link to header](#header-name)           # Default format\n[Link to header](#markdown-header-name)  # Bitbucket format\n</code></pre>"},{"location":"markdown-quick-reference/#footnotes","title":"Footnotes","text":"<pre><code>Text with footnote[^1].\n\n[^1]: Footnote content with [link](url).\n</code></pre>"},{"location":"markdown-quick-reference/#images","title":"Images","text":"<pre><code>![Alt text](local/image.png)     # Auto-uploaded as attachment\n![Alt text](http://url/img.png)  # External URL preserved\n</code></pre>"},{"location":"markdown-quick-reference/#special-options","title":"Special Options","text":"<ul> <li><code>--remove-emojies</code>: Remove all Unicode emojis</li> <li><code>--add-contents</code>: Add comprehensive table of contents</li> <li><code>--markdownsrc default|bitbucket</code>: Set anchor link format</li> </ul>"},{"location":"markdown-quick-reference/#standard-markdown","title":"Standard Markdown","text":"<p>All standard markdown is supported: - Headers: <code># ## ### #### ##### ######</code> - Bold, italic, ~~strikethrough~~, <code>inline code</code> - Lists: <code>* - +</code> and <code>1. 2. 3.</code> - Tables: <code>| col1 | col2 |</code> - Links: <code>[text](url)</code> - Images: <code>![alt](src)</code></p> <p>For complete documentation, see markdown-syntax.md.</p>"},{"location":"markdown-syntax/","title":"Markdown Syntax Guide","text":"<p>This document describes the standard and special markdown syntax supported by the md_to_conf converter. The converter transforms markdown files into Confluence-compatible HTML using the Python <code>markdown</code> library with additional custom processing.</p>"},{"location":"markdown-syntax/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Standard Markdown Support</li> <li>Special Confluence Features</li> <li>GitHub-Flavored Markdown Alerts</li> <li>Custom Panel Syntax</li> <li>Table of Contents Generation</li> <li>Code Blocks</li> <li>Comments</li> <li>References and Footnotes</li> <li>Internal Links</li> <li>Images and Attachments</li> <li>Emoji Support</li> </ul>"},{"location":"markdown-syntax/#standard-markdown-support","title":"Standard Markdown Support","text":"<p>The converter supports all standard markdown syntax through the Python <code>markdown</code> library with the following extensions enabled:</p>"},{"location":"markdown-syntax/#headers","title":"Headers","text":"<pre><code># Header 1\n## Header 2  \n### Header 3\n#### Header 4\n##### Header 5\n###### Header 6\n</code></pre> <p>Headers are converted to Confluence headings and can be used as anchor targets for internal links.</p>"},{"location":"markdown-syntax/#text-formatting","title":"Text Formatting","text":"<pre><code>**Bold text**\n*Italic text*\n***Bold and italic***\n~~Strikethrough~~\n`Inline code`\n</code></pre>"},{"location":"markdown-syntax/#lists","title":"Lists","text":""},{"location":"markdown-syntax/#unordered-lists","title":"Unordered Lists","text":"<pre><code>* Item 1\n* Item 2\n  * Nested item 2.1\n  * Nested item 2.2\n* Item 3\n</code></pre>"},{"location":"markdown-syntax/#ordered-lists","title":"Ordered Lists","text":"<pre><code>1. First item\n2. Second item\n   1. Nested item 2.1\n   2. Nested item 2.2\n3. Third item\n</code></pre> <p>The converter uses the <code>mdx_truly_sane_lists</code> extension for proper nested list handling.</p>"},{"location":"markdown-syntax/#tables","title":"Tables","text":"<pre><code>| Column 1 | Column 2 | Column 3 |\n|----------|----------|----------|\n| Row 1    | Data     | Data     |\n| Row 2    | Data     | Data     |\n</code></pre> <p>Tables are supported through the <code>tables</code> extension and converted to Confluence table format.</p>"},{"location":"markdown-syntax/#links","title":"Links","text":"<pre><code>[Link text](https://example.com)\n[Link with title](https://example.com \"Title\")\n</code></pre>"},{"location":"markdown-syntax/#blockquotes","title":"Blockquotes","text":"<pre><code>&gt; This is a blockquote\n&gt; \n&gt; Multiple lines are supported\n</code></pre> <p>See Special Confluence Features for enhanced blockquote functionality.</p>"},{"location":"markdown-syntax/#special-confluence-features","title":"Special Confluence Features","text":""},{"location":"markdown-syntax/#enhanced-blockquotes-with-status-panels","title":"Enhanced Blockquotes with Status Panels","text":"<p>The converter automatically detects special blockquote patterns and converts them to Confluence status panels:</p>"},{"location":"markdown-syntax/#info-panel-blue-icon","title":"Info Panel (Blue Icon)","text":"<pre><code>&gt; This is general information.\n</code></pre>"},{"location":"markdown-syntax/#warning-panel-yellow-caution-icon","title":"Warning Panel (Yellow Caution Icon)","text":"<pre><code>&gt; Warning: This is a warning message.\n</code></pre>"},{"location":"markdown-syntax/#success-panel-green-check-icon","title":"Success Panel (Green Check Icon)","text":"<pre><code>&gt; Success: This is a success message.\n</code></pre>"},{"location":"markdown-syntax/#error-panel-red-cross-icon","title":"Error Panel (Red Cross Icon)","text":"<pre><code>&gt; Error: This is an error message.\n</code></pre>"},{"location":"markdown-syntax/#note-panel-special-adf-format","title":"Note Panel (Special ADF Format)","text":"<pre><code>&gt; Note: This is a note.\n</code></pre> <p>Note: The type detection is case-insensitive and supports various formats like \"Warning:\", \"Warning :\", etc.</p>"},{"location":"markdown-syntax/#github-flavored-markdown-alerts","title":"GitHub-Flavored Markdown Alerts","text":"<p>The converter supports GitHub-flavored markdown alert syntax, which takes precedence over traditional blockquote processing. These alerts provide a standardized way to create different types of callout panels.</p>"},{"location":"markdown-syntax/#supported-alert-types","title":"Supported Alert Types","text":""},{"location":"markdown-syntax/#note-alert","title":"NOTE Alert","text":"<pre><code>&gt; [!NOTE]\n&gt; Useful information that users should know, even when skimming content.\n</code></pre> <p>Converts to a Confluence info panel (blue icon).</p>"},{"location":"markdown-syntax/#tip-alert","title":"TIP Alert","text":"<pre><code>&gt; [!TIP]\n&gt; Helpful advice for doing things better or more easily.\n</code></pre> <p>Converts to a Confluence tip panel (green icon).</p>"},{"location":"markdown-syntax/#important-alert","title":"IMPORTANT Alert","text":"<pre><code>&gt; [!IMPORTANT]\n&gt; Key information users need to know to achieve their goal.\n</code></pre> <p>Converts to a special Confluence ADF panel with note styling.</p>"},{"location":"markdown-syntax/#warning-alert","title":"WARNING Alert","text":"<pre><code>&gt; [!WARNING]\n&gt; Urgent info that needs immediate user attention to avoid problems.\n</code></pre> <p>Converts to a Confluence note panel (yellow caution icon).</p>"},{"location":"markdown-syntax/#caution-alert","title":"CAUTION Alert","text":"<pre><code>&gt; [!CAUTION]\n&gt; Advises about risks or negative outcomes of certain actions.\n</code></pre> <p>Converts to a Confluence warning panel (red cross icon).</p>"},{"location":"markdown-syntax/#features","title":"Features","text":"<ul> <li>Case Insensitive: Works with <code>[!note]</code>, <code>[!NOTE]</code>, <code>[!Note]</code>, etc.</li> <li>Multi-line Support: Supports multiple paragraphs within alerts</li> <li>HTML Formatting: Preserves bold, italic, and other formatting inside alerts</li> <li>Precedence: GitHub alerts are processed before traditional blockquote patterns</li> <li>Single Line: Content can be on the same line as the alert type</li> </ul>"},{"location":"markdown-syntax/#examples","title":"Examples","text":""},{"location":"markdown-syntax/#single-line-alert","title":"Single Line Alert","text":"<pre><code>&gt; [!WARNING] This is a single-line warning message.\n</code></pre>"},{"location":"markdown-syntax/#multi-line-alert","title":"Multi-line Alert","text":"<pre><code>&gt; [!IMPORTANT]\n&gt; This is the first paragraph of an important message.\n&gt;\n&gt; This is a second paragraph with **bold** and *italic* formatting.\n</code></pre>"},{"location":"markdown-syntax/#mixed-content","title":"Mixed Content","text":"<pre><code>&gt; [!TIP]\n&gt; Here's a helpful tip with a code example:\n&gt;\n&gt; ```bash\n&gt; npm install package-name\n&gt; ```\n</code></pre>"},{"location":"markdown-syntax/#custom-panel-syntax","title":"Custom Panel Syntax","text":"<p>For more explicit control over panel types, use the custom tilde syntax:</p>"},{"location":"markdown-syntax/#info-panel","title":"Info Panel","text":"<pre><code>~?This is an info panel.?~\n</code></pre>"},{"location":"markdown-syntax/#warning-panel","title":"Warning Panel","text":"<pre><code>~%This is a warning panel.%~\n</code></pre>"},{"location":"markdown-syntax/#success-panel","title":"Success Panel","text":"<pre><code>~^This is a success panel.^~\n</code></pre>"},{"location":"markdown-syntax/#error-panel","title":"Error Panel","text":"<pre><code>~$This is an error panel.$~\n</code></pre>"},{"location":"markdown-syntax/#note-panel","title":"Note Panel","text":"<pre><code>~!This is a note panel.!~\n</code></pre>"},{"location":"markdown-syntax/#table-of-contents-generation","title":"Table of Contents Generation","text":""},{"location":"markdown-syntax/#simple-toc","title":"Simple TOC","text":"<pre><code>[TOC]\n</code></pre> <p>This creates a basic table of contents macro in Confluence.</p>"},{"location":"markdown-syntax/#doctoc-integration","title":"DocToc Integration","text":"<pre><code>&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;\n&lt;!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt;\n&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt;\n</code></pre> <p>The converter automatically replaces doctoc-generated sections with Confluence TOC macros with advanced parameters: - Printable: true - Style: disc - Max Level: 7 - Min Level: 1 - Type: list - Outline: clear</p>"},{"location":"markdown-syntax/#contents-addition","title":"Contents Addition","text":"<p>When using the <code>--add-contents</code> option, a comprehensive table of contents is automatically added to the beginning of the page with these parameters: - Printable: true - Style: disc - Max Level: 5 - Min Level: 1 - Class: rm-contents - Type: list - Outline: false</p>"},{"location":"markdown-syntax/#code-blocks","title":"Code Blocks","text":""},{"location":"markdown-syntax/#fenced-code-blocks","title":"Fenced Code Blocks","text":"<pre><code>```javascript\nfunction example() {\n    return \"Hello, World!\";\n}\n```\n</code></pre>"},{"location":"markdown-syntax/#code-block-without-language","title":"Code Block without Language","text":"<pre><code>```\nThis is a generic code block\n```\n</code></pre> <p>Features: - All code blocks are converted to Confluence code macros - Theme: Midnight (dark theme) - Line numbers: enabled - Language detection from fence language specification - Falls back to \"none\" if no language specified - HTML entities are properly unescaped</p> <p>Supported Languages: Any language supported by Confluence code macros (JavaScript, Python, Java, SQL, etc.)</p>"},{"location":"markdown-syntax/#comments","title":"Comments","text":""},{"location":"markdown-syntax/#html-comments","title":"HTML Comments","text":"<pre><code>&lt;!-- This is a hidden comment --&gt;\n</code></pre> <p>HTML comments are converted to Confluence placeholder macros (<code>&lt;ac:placeholder&gt;</code>) which render as hidden comments in Confluence.</p>"},{"location":"markdown-syntax/#references-and-footnotes","title":"References and Footnotes","text":""},{"location":"markdown-syntax/#footnote-references","title":"Footnote References","text":"<pre><code>Here is some text with a footnote reference[^1].\n\n[^1]: This is the footnote content with a [link](https://example.com).\n</code></pre> <p>Features: - Footnotes are supported through the <code>footnotes</code> extension - References are converted to superscript links - Footnote content is processed and linked appropriately</p>"},{"location":"markdown-syntax/#internal-links","title":"Internal Links","text":""},{"location":"markdown-syntax/#header-anchor-links","title":"Header Anchor Links","text":"<pre><code>[Link to section](#header-name)\n</code></pre> <p>Features: - Links to headers within the same page are automatically converted - Supports both <code>default</code> and <code>bitbucket</code> markdown source formats - Different anchor prefixes based on source:   - Default: <code>#</code>   - Bitbucket: <code>#markdown-header-</code> - Proper URL encoding for Confluence page URLs - Different output formats for editor versions 1 and 2</p>"},{"location":"markdown-syntax/#supported-markdown-sources","title":"Supported Markdown Sources","text":""},{"location":"markdown-syntax/#default-format","title":"Default Format","text":"<pre><code>[Link to header](#my-header)\n</code></pre>"},{"location":"markdown-syntax/#bitbucket-format","title":"Bitbucket Format","text":"<pre><code>[Link to header](#markdown-header-my-header)\n</code></pre>"},{"location":"markdown-syntax/#images-and-attachments","title":"Images and Attachments","text":""},{"location":"markdown-syntax/#image-syntax","title":"Image Syntax","text":"<pre><code>![Alt text](path/to/image.png)\n![Alt text with title](path/to/image.png \"Image title\")\n</code></pre> <p>Features: - Local images are automatically uploaded as Confluence attachments - Image paths are converted to Confluence attachment URLs - HTTP/HTTPS URLs are left unchanged - Alt text is preserved in the attachment metadata</p> <p>Automatic Processing: - Local file paths are resolved relative to the markdown file location - Images are uploaded to the target Confluence page - Image references are updated to point to Confluence attachment URLs - Format: <code>/wiki/download/attachments/{page_id}/{filename}</code> or <code>/download/attachments/{page_id}/{filename}</code></p>"},{"location":"markdown-syntax/#emoji-support","title":"Emoji Support","text":""},{"location":"markdown-syntax/#emoji-removal","title":"Emoji Removal","text":"<p>When using the <code>--remove-emojies</code> option, the converter removes Unicode emoji characters:</p> <p>Removed Emoji Ranges: - Emoticons: <code>\\U0001F600-\\U0001F64F</code> - Symbols &amp; Pictographs: <code>\\U0001F300-\\U0001F5FF</code> - Transport &amp; Map Symbols: <code>\\U0001F680-\\U0001F6FF</code> - Flags (iOS): <code>\\U0001F1E0-\\U0001F1FF</code></p> <p>Example:</p> <pre><code>This text has emojis \ud83d\ude00 \ud83c\udf89 \ud83d\ude80 \ud83c\uddfa\ud83c\uddf8\n</code></pre> <p>With <code>--remove-emojies</code>, becomes:</p> <pre><code>This text has emojis\n</code></pre>"},{"location":"markdown-syntax/#advanced-features","title":"Advanced Features","text":""},{"location":"markdown-syntax/#command-line-options","title":"Command Line Options","text":"<p>The converter supports several command-line options that affect markdown processing:</p>"},{"location":"markdown-syntax/#content-options","title":"Content Options","text":"<ul> <li><code>--contents</code> / <code>-c</code>: Generate a comprehensive table of contents at the beginning of the page</li> <li><code>--title</code>: Set a custom page title (otherwise uses first line of markdown file)</li> <li><code>--remove-emojies</code>: Remove all Unicode emojis from the content</li> </ul>"},{"location":"markdown-syntax/#markdown-source-format","title":"Markdown Source Format","text":"<ul> <li><code>--markdownsrc</code> / <code>-mds</code>: Specify markdown source format</li> <li><code>default</code>: Standard markdown anchor format (<code>#header-name</code>)</li> <li><code>bitbucket</code>: Bitbucket-style anchors (<code>#markdown-header-header-name</code>)</li> </ul>"},{"location":"markdown-syntax/#page-management","title":"Page Management","text":"<ul> <li><code>--label</code>: Add labels to the Confluence page (can be used multiple times)</li> <li><code>--property</code>: Set content properties on the page (format: <code>key=value</code>, can be used multiple times)</li> <li><code>--attachment</code> / <code>-t</code>: Upload file attachments to the page (paths relative to markdown file)</li> </ul>"},{"location":"markdown-syntax/#processing-options","title":"Processing Options","text":"<ul> <li><code>--version</code> / <code>-v</code>: Confluence editor version (1 or 2, default: 2)</li> <li><code>--simulate</code> / <code>-s</code>: Show conversion result without uploading to Confluence</li> <li><code>--delete</code> / <code>-d</code>: Delete the page instead of creating/updating it</li> </ul>"},{"location":"markdown-syntax/#editor-version-support","title":"Editor Version Support","text":"<p>The converter supports two editor versions with different output formats:</p>"},{"location":"markdown-syntax/#editor-version-1-legacy","title":"Editor Version 1 (Legacy)","text":"<ul> <li>Uses Confluence-specific XML link format</li> <li>Internal links: <code>&lt;ac:link ac:anchor=\"...\"&gt;&lt;ac:plain-text-link-body&gt;&lt;![CDATA[...]]&gt;&lt;/ac:plain-text-link-body&gt;&lt;/ac:link&gt;</code></li> </ul>"},{"location":"markdown-syntax/#editor-version-2-modern","title":"Editor Version 2 (Modern)","text":"<ul> <li>Uses standard HTML anchor links</li> <li>Internal links: <code>&lt;a href=\"...#...\" title=\"...\"&gt;...&lt;/a&gt;</code></li> <li>Full Confluence page URLs with anchor fragments</li> </ul>"},{"location":"markdown-syntax/#markdown-source-formats","title":"Markdown Source Formats","text":""},{"location":"markdown-syntax/#default-source","title":"Default Source","text":"<ul> <li>Standard markdown anchor format: <code>#header-name</code></li> <li>Postfix pattern for duplicates: <code>_%d</code></li> </ul>"},{"location":"markdown-syntax/#bitbucket-source","title":"Bitbucket Source","text":"<ul> <li>Bitbucket-style anchors: <code>#markdown-header-header-name</code></li> <li>Postfix pattern for duplicates: <code>_%d</code></li> </ul>"},{"location":"markdown-syntax/#processing-order","title":"Processing Order","text":"<p>The converter processes markdown in this order: 1. Convert markdown to HTML using Python <code>markdown</code> library 2. Remove title if not explicitly provided 3. Process table of contents markers 4. Convert info/warning/success/error macros 5. Convert HTML comments to placeholders 6. Convert code blocks to Confluence macros 7. Remove emojis (if requested) 8. Add contents section (if requested) 9. Process footnote references 10. Process internal anchor links</p>"},{"location":"markdown-syntax/#limitations-and-notes","title":"Limitations and Notes","text":"<ol> <li> <p>Internal Links: Only work within the same page. Cross-page links are not automatically converted.</p> </li> <li> <p>Image Processing: Only local images are uploaded as attachments. External URLs are preserved as-is.</p> </li> <li> <p>Code Language Detection: Language detection relies on the fence specification. Unknown languages default to \"none\".</p> </li> <li> <p>Panel Type Detection: Blockquote panel type detection is case-insensitive but requires specific keywords (Warning, Success, Error, Note).</p> </li> <li> <p>Anchor Generation: Anchor names are automatically generated from header text with special character removal and space-to-dash conversion.</p> </li> <li> <p>Nested Lists: Proper indentation is required for nested list items (2+ spaces for sub-items).</p> </li> <li> <p>Emoji Removal: When enabled, removes all emojis indiscriminately - cannot selectively preserve certain emojis.</p> </li> </ol>"},{"location":"markdown-syntax/#examples_1","title":"Examples","text":"<p>For complete examples, see the test files: - <code>tests/testfiles/basic.md</code> - Basic markdown features - <code>tests/testfiles/advanced.md</code> - Advanced features including panels, nested lists, and internal links</p>"},{"location":"api/client-reference/","title":"Client","text":""},{"location":"api/client-reference/#md_to_conf.client.CheckedResponse","title":"<code>CheckedResponse</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>NamedTuple containing page information</p> Source code in <code>md_to_conf/client.py</code> <pre><code>class CheckedResponse(typing.NamedTuple):\n    \"\"\"\n    NamedTuple containing page information\n\n    \"\"\"\n\n    status_code: int\n    \"\"\" Page Id \"\"\"\n\n    data: any\n    \"\"\" Generic object from JSON response \"\"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.CheckedResponse.data","title":"<code>data</code>  <code>instance-attribute</code>","text":"<p>Generic object from JSON response</p>"},{"location":"api/client-reference/#md_to_conf.client.CheckedResponse.status_code","title":"<code>status_code</code>  <code>instance-attribute</code>","text":"<p>Page Id</p>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient","title":"<code>ConfluenceApiClient</code>","text":"Source code in <code>md_to_conf/client.py</code> <pre><code>class ConfluenceApiClient:\n    def __init__(\n        self,\n        confluence_api_url: str,\n        username: str,\n        api_key: str,\n        space_key: str,\n        editor_version: int,\n        use_ssl: bool = True,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            username:  The Confluence user name associated with the API key\n            api_key: The API key to access Confluence\n            confluence_api_url: The URL to the Confluence site\n            space_key: The Key value for the Space for publishing\n            editor_version: The editor version for page publishing\n            use_ssl:  Whether or not to use SSL.\n\n        \"\"\"\n        self.user_name = username\n        self.api_key = api_key\n        self.confluence_api_url = confluence_api_url\n        self.space_key = space_key\n        self.space_id = -1\n        self.space_home_page_id = -1\n        self.editor_version = editor_version\n        self.use_ssl = use_ssl\n\n    def get_session(self, retry: bool = False, json: bool = True) -&gt; requests.Session:\n        \"\"\"\n        Retrieve a `requests` session object\n\n        Args:\n            retry: Configure the request with a retry adapter.\n            json: Configure the request to set Content-Type to 'application/json'\n        Returns:\n            requests.Session: A session from the `requests` module\n\n        \"\"\"\n        session = requests.Session()\n        if retry:\n            retry_max_requests = 5\n            retry_backoff_factor = 0.1\n            retry_status_forcelist = (404, 500, 501, 502, 503, 504)\n            retry = requests.adapters.Retry(\n                total=retry_max_requests,\n                connect=retry_max_requests,\n                read=retry_max_requests,\n                backoff_factor=retry_backoff_factor,\n                status_forcelist=retry_status_forcelist,\n            )\n            adapter = requests.adapters.HTTPAdapter(max_retries=retry)\n            if self.use_ssl:\n                session.mount(\"https://\", adapter)\n            else:\n                session.mount(\"http://\", adapter)\n\n        session.auth = (self.user_name, self.api_key)\n        if json:\n            session.headers.update({\"Content-Type\": \"application/json\"})\n        return session\n\n    def log_not_found(self, object_name: str, log_values: dict[str, str]):\n        \"\"\"\n        Write a \"not found\" message to the LOGGER\n\n        Args:\n            object_name: The name to show in the log message\n            log_values: Additional key/value pairs to log\n\n        \"\"\"\n        LOGGER.error(f\"{object_name} not found.\")\n        LOGGER.error(\"Diagnostic Information\")\n        LOGGER.error(f\"\\tURL: {self.confluence_api_url}\")\n        for key in log_values:\n            LOGGER.error(f\"\\t{key}: {log_values[key]}\")\n\n    def check_errors_and_get_json(self, response: requests.Response) -&gt; CheckedResponse:\n        \"\"\"\n        Check the response for error codes\n\n        Args:\n            response : The response from a request\n\n        \"\"\"\n        try:\n            response.raise_for_status()\n        except requests.RequestException as err:\n            LOGGER.debug(\"err.response: %s\", err)\n            if response.status_code == 404:\n                return CheckedResponse(404, {\"error\": \"Not Found\"})\n            else:\n                LOGGER.error(\"Error: %d - %s\", response.status_code, response.content)\n                sys.exit(1)\n\n        return CheckedResponse(response.status_code, response.json())\n\n    def update_page(\n        self, page_id: int, title: str, body: str, version: int, parent_id: int\n    ):\n        \"\"\"\n        Update a page\n\n        Args:\n            page_id: confluence page id\n            title: confluence page title\n            body: confluence page content\n            version: confluence page version\n            parent_id: confluence parentId\n        \"\"\"\n        LOGGER.info(\"Updating page...\")\n\n        url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n        page_json = {\n            \"id\": page_id,\n            \"type\": \"page\",\n            \"title\": title,\n            \"spaceId\": \"%s\" % self.get_space_id(),\n            \"status\": \"current\",\n            \"body\": {\"value\": body, \"representation\": \"storage\"},\n            \"version\": {\"number\": version + 1, \"minorEdit\": True},\n            \"parentId\": \"%s\" % parent_id,\n        }\n\n        session = self.get_session()\n        response = self.check_errors_and_get_json(\n            session.put(url, data=json.dumps(page_json))\n        )\n\n        if response.status_code == 404:\n            self.log_not_found(\"Page\", {PAGE_ID_KEY: \"%d\" % page_id})\n            return False\n\n        if response.status_code == 200:\n            link = \"%s%s\" % (self.confluence_api_url, response.data[\"_links\"][\"webui\"])\n            LOGGER.info(\"Page updated successfully.\")\n            LOGGER.info(\"URL: %s\", link)\n            return True\n        else:\n            LOGGER.error(\"Page could not be updated.\")\n\n    def get_space_id(self) -&gt; int:\n        \"\"\"\n        Retrieve the integer space ID for the current self.space_key\n\n        Returns:\n            The integer ID for the space_key of this instance\n\n        \"\"\"\n        if self.space_id &gt; -1:\n            return self.space_id\n\n        url = \"%s/api/v2/spaces?keys=%s\" % (self.confluence_api_url, self.space_key)\n\n        response = self.check_errors_and_get_json(self.get_session().get(url))\n\n        if response.status_code == 404:\n            self.log_not_found(\"Space\", {\"Space Key\": self.space_key})\n        else:\n            if len(response.data[\"results\"]) &gt;= 1:\n                self.space_id = int(response.data[\"results\"][0][\"id\"])\n                self.space_home_page_id = int(response.data[\"results\"][0][\"homepageId\"])\n\n        return self.space_id\n\n    def create_page(self, title: str, body: str, parent_id: int) -&gt; PageInfo:\n        \"\"\"\n        Create a new page\n\n        Args:\n            title: confluence page title\n            body: confluence page content\n            parent_id: confluence parentId\n\n        Returns:\n            PageInfo: A named tuple with page information\n        \"\"\"\n        LOGGER.info(\"Creating page...\")\n\n        url = \"%s/api/v2/pages\" % self.confluence_api_url\n\n        space_id = self.get_space_id()\n\n        new_page = {\n            \"title\": title,\n            \"spaceId\": \"%d\" % space_id,\n            \"status\": \"current\",\n            \"body\": {\"value\": body, \"representation\": \"storage\"},\n            \"parentId\": \"%s\" % parent_id,\n        }\n\n        LOGGER.debug(\"data: %s\", json.dumps(new_page))\n\n        response = self.check_errors_and_get_json(\n            self.get_session().post(url, data=json.dumps(new_page))\n        )\n\n        if response.status_code == 200:\n            data = response.data\n            space_id = int(data[\"spaceId\"])\n            page_id = int(data[\"id\"])\n            version = data[\"version\"][\"number\"]\n            link = \"%s%s\" % (self.confluence_api_url, data[\"_links\"][\"webui\"])\n\n            LOGGER.info(\"Page created in SpaceId %d with ID: %d.\", space_id, page_id)\n            LOGGER.info(\"URL: %s\", link)\n\n            return PageInfo(page_id, space_id, version, link)\n        else:\n            LOGGER.error(\"Could not create page.\")\n            return PageInfo(0, 0, 0, \"\")\n\n    def delete_page(self, page_id: int):\n        \"\"\"\n        Delete a page\n\n        Args:\n            page_id: confluence page id\n        \"\"\"\n        LOGGER.info(\"Deleting page...\")\n        url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n        response = self.get_session().delete(url)\n        response.raise_for_status()\n\n        if response.status_code == 204:\n            LOGGER.info(\"Page %d deleted successfully.\", page_id)\n        else:\n            LOGGER.error(\"Page %d could not be deleted.\", page_id)\n\n    def get_page(self, title: str) -&gt; PageInfo:\n        \"\"\"\n        Retrieve page details by title\n\n        Args:\n            title: page title\n        Returns:\n            Confluence page info\n        \"\"\"\n\n        space_id = self.get_space_id()\n\n        LOGGER.info(\"\\tRetrieving page information: %s\", title)\n        url = \"%s/api/v2/spaces/%d/pages?title=%s\" % (\n            self.confluence_api_url,\n            space_id,\n            urllib.parse.quote_plus(title),\n        )\n\n        response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n        if response.status_code == 404:\n            self.log_not_found(\"Page\", {\"Space Id\": \"%d\" % space_id})\n        else:\n            data = response.data\n\n            LOGGER.debug(\"data: %s\", str(data))\n\n            if len(data[\"results\"]) &gt;= 1:\n                page_id = int(data[\"results\"][0][\"id\"])\n                space_id = int(data[\"results\"][0][\"spaceId\"])\n                version_num = data[\"results\"][0][\"version\"][\"number\"]\n                link = \"%s%s\" % (\n                    self.confluence_api_url,\n                    data[\"results\"][0][\"_links\"][\"webui\"],\n                )\n\n                page = PageInfo(page_id, space_id, version_num, link)\n                return page\n\n        return PageInfo(0, 0, 0, \"\")\n\n    def get_page_properties(self, page_id: int) -&gt; typing.List[typing.Any]:\n        \"\"\"\n        Retrieve page properties by page id\n\n        Args:\n            page_id: pageId\n        Returns:\n            Page Properties Collection\n        \"\"\"\n\n        LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n        url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n\n        response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n        if response.status_code == 404:\n            self.log_not_found(\"Page Properties\", {PAGE_ID_KEY: \"%d\" % page_id})\n        else:\n            return response.data[\"results\"]\n\n        return []\n\n    def get_folder(self, folder_name: str) -&gt; int:\n        \"\"\"\n        Get folder information for the given folder name\n\n        Args:\n            folder_name: Title of the folder to search for.\n\n        \"\"\"\n\n        # This call populates self.space_home_page_id\n        self.get_space_id()\n\n        LOGGER.debug(\"\\tRetrieving folder information: %s\", folder_name)\n        url = \"%s/api/v2/pages/%d/descendants?depth=5\" % (\n            self.confluence_api_url,\n            self.space_home_page_id,\n        )\n\n        folder_id = 0\n\n        while True:\n            LOGGER.debug(\"Requesting URL for Folder: %s\", url)\n            response = self.check_errors_and_get_json(\n                self.get_session(retry=True).get(url)\n            )\n            if response.status_code == 404:\n                self.log_not_found(\n                    \"Folder\", {\"Space Home Page Id\": \"%d\" % self.space_home_page_id}\n                )\n                break  # Exit the loop on 404\n\n            for item in response.data[\"results\"]:\n                if item[\"title\"] == folder_name and item[\"type\"] == \"folder\":\n                    folder_id = int(item[\"id\"])\n                    break\n\n            base = response.data.get(\"_links\", {}).get(\"base\", None)\n            url = response.data.get(\"_links\", {}).get(\"next\", None)\n\n            if not url:\n                break\n\n            if base:\n                base = base.replace(\"/wiki\", \"\")\n                url = urllib.parse.urljoin(base, url)\n\n        return folder_id\n\n    def update_page_property(self, page_id: int, page_property) -&gt; bool:\n        \"\"\"\n        Update page property by page id\n\n        Args:\n            page_id: pageId\n        Returns:\n            True if successful\n        \"\"\"\n\n        property_json = {\n            \"page-id\": page_id,\n            \"key\": page_property[\"key\"],\n            \"value\": page_property[\"value\"],\n            \"version\": {\"number\": page_property[\"version\"], \"minorEdit\": True},\n        }\n\n        if \"id\" in page_property:\n            url = \"%s/api/v2/pages/%d/properties/%s\" % (\n                self.confluence_api_url,\n                page_id,\n                page_property[\"id\"],\n            )\n            property_json.update({\"property-id\": page_property[\"id\"]})\n            LOGGER.info(\n                \"Updating Property ID %s on Page %d: %s=%s\",\n                property_json[\"property-id\"],\n                page_id,\n                property_json[\"key\"],\n                property_json[\"value\"],\n            )\n            response = self.check_errors_and_get_json(\n                self.get_session(retry=True).put(url, data=json.dumps(property_json))\n            )\n        else:\n            url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n            LOGGER.info(\n                \"Adding Property to Page %s: %s=%s\",\n                page_id,\n                property_json[\"key\"],\n                property_json[\"value\"],\n            )\n            response = self.check_errors_and_get_json(\n                self.get_session(retry=True).post(url, data=json.dumps(property_json))\n            )\n\n        if response.status_code != 200:\n            LOGGER.error(\n                \"Unable to add property %s to page %d\", property_json[\"key\"], page_id\n            )\n            return False\n        else:\n            return True\n\n    def get_attachment(self, page_id: int, filename: str) -&gt; str:\n        \"\"\"\n        Get page attachment\n\n        Args:\n            page_id: confluence page id\n            filename: attachment filename\n        Returns:\n            The attachment Id, or -1 if not found\n        \"\"\"\n        url = \"%s/api/v2/pages/%d/attachments?filename=%s\" % (\n            self.confluence_api_url,\n            page_id,\n            urllib.parse.quote_plus(filename),\n        )\n\n        response = self.check_errors_and_get_json(self.get_session().get(url))\n\n        if response.status_code == 404:\n            self.log_not_found(\n                \"Attachment\",\n                {PAGE_ID_KEY: \"%d\" % page_id, \"Filename\": filename}\n            )\n            return \"\"\n\n        if len(response.data[\"results\"]) &gt;= 1:\n            att_id = response.data[\"results\"][0][\"id\"]\n            return att_id\n\n        return \"\"\n\n    def upload_attachment(self, page_id: int, file: str, comment: str) -&gt; bool:\n        \"\"\"\n        Upload an attachement\n\n        Args:\n            page_id: confluence page id\n            file: attachment file\n            comment: attachment comment\n        Returns:\n            True if successful, false otherwise\n        \"\"\"\n        if re.search(r\"http.*\", file):\n            return False\n\n        content_type = mimetypes.guess_type(file)[0]\n        filename = os.path.basename(file)\n\n        if not os.path.isfile(file):\n            LOGGER.error(\"File %s cannot be found --&gt; skip \", file)\n            return False\n\n        file_to_upload = {\n            \"comment\": comment,\n            \"file\": (filename, open(file, \"rb\"), content_type, {\"Expires\": \"0\"}),\n        }\n\n        attachment_id = self.get_attachment(page_id, filename)\n        if attachment_id != \"\":\n            # Update existing attachment using v2 API\n            url = \"%s/rest/api/content/%d/child/attachment/%s/data\" % (\n                self.confluence_api_url,\n                page_id,\n                attachment_id,\n            )\n        else:\n            # Create new attachment using v2 API\n            url = \"%s/rest/api/content/%d/child/attachment/\" % (\n                self.confluence_api_url,\n                page_id,\n            )\n\n        session = self.get_session(json=False)\n        session.headers.update({\"X-Atlassian-Token\": \"no-check\"})\n\n        LOGGER.info(\"\\tUploading attachment %s...\", filename)\n\n        response = session.post(url, files=file_to_upload)\n        response.raise_for_status()\n\n        return True\n\n    def get_label_info(self, label_name: str) -&gt; LabelInfo:\n        \"\"\"\n        Get label information for the given label name\n\n        Args:\n            label_name: label name to search for\n        Returns:\n            LabelInfo.  If not found, labelInfo will be 0\n        \"\"\"\n\n        LOGGER.debug(\"\\tRetrieving label information: %s\", label_name)\n        # Note: Keep using v1 API for labels as v2 API doesn't have equivalent endpoints\n        url = \"%s/rest/api/label?name=%s\" % (\n            self.confluence_api_url,\n            urllib.parse.quote_plus(label_name),\n        )\n\n        response = self.check_errors_and_get_json(self.get_session().get(url))\n\n        if response.status_code == 404:\n            label = LabelInfo(0, \"\", \"\", \"\")\n        else:\n            data = response.data[\"label\"]\n            label = LabelInfo(\n                int(data[\"id\"]),\n                data[\"name\"],\n                data[\"prefix\"],\n                data[\"label\"],\n            )\n\n        return label\n\n    def add_label(self, page_id: int, label_name: str) -&gt; bool:\n        \"\"\"\n        Add the given label to the given page Id\n\n        Args:\n            page_id: pageId\n            label_name: label to be added\n        Returns:\n            True if successful\n        \"\"\"\n        label_info = self.get_label_info(label_name)\n        if label_info.id &gt; 0:\n            prefix = label_info.prefix\n        else:\n            prefix = \"global\"\n\n        add_label_json = {\"prefix\": prefix, \"name\": label_name}\n\n        # Note: Keep using v1 API for labels as v2 API doesn't have equivalent endpoints\n        url = \"%s/rest/api/content/%d/label\" % (self.confluence_api_url, page_id)\n\n        response = self.get_session().post(url, data=json.dumps(add_label_json))\n        response.raise_for_status()\n        return True\n\n    def update_labels(self, page_id: int, labels: typing.List[str]) -&gt; bool:\n        \"\"\"\n        Update labels on given page Id\n\n        Args:\n            page_id: pageId\n            labels: labels to be added\n        Returns:\n            True if successful\n        \"\"\"\n\n        LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n        url = \"%s/api/v2/pages/%d/labels\" % (self.confluence_api_url, page_id)\n\n        response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n        if response.status_code == 404:\n            LOGGER.error(\n                \"Error: Error finding existing labels. Check the following are correct:\"\n            )\n            LOGGER.error(\"\\t%s : %d\", PAGE_ID_KEY, page_id)\n            LOGGER.error(\"\\tURL: %s\", self.confluence_api_url)\n            return False\n\n        data = response.data\n        for label in labels:\n            found = False\n            for existing_label in data[\"results\"]:\n                if label == existing_label[\"name\"]:\n                    found = True\n\n            if not found:\n                LOGGER.info(\"Adding Label '%s' to %s %d\", label, PAGE_ID_KEY, page_id)\n                self.add_label(page_id, label)\n\n            LOGGER.debug(\"property data: %s\", str(data[\"results\"]))\n\n        return data[\"results\"]\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.__init__","title":"<code>__init__(confluence_api_url, username, api_key, space_key, editor_version, use_ssl=True)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The Confluence user name associated with the API key</p> required <code>api_key</code> <code>str</code> <p>The API key to access Confluence</p> required <code>confluence_api_url</code> <code>str</code> <p>The URL to the Confluence site</p> required <code>space_key</code> <code>str</code> <p>The Key value for the Space for publishing</p> required <code>editor_version</code> <code>int</code> <p>The editor version for page publishing</p> required <code>use_ssl</code> <code>bool</code> <p>Whether or not to use SSL.</p> <code>True</code> Source code in <code>md_to_conf/client.py</code> <pre><code>def __init__(\n    self,\n    confluence_api_url: str,\n    username: str,\n    api_key: str,\n    space_key: str,\n    editor_version: int,\n    use_ssl: bool = True,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        username:  The Confluence user name associated with the API key\n        api_key: The API key to access Confluence\n        confluence_api_url: The URL to the Confluence site\n        space_key: The Key value for the Space for publishing\n        editor_version: The editor version for page publishing\n        use_ssl:  Whether or not to use SSL.\n\n    \"\"\"\n    self.user_name = username\n    self.api_key = api_key\n    self.confluence_api_url = confluence_api_url\n    self.space_key = space_key\n    self.space_id = -1\n    self.space_home_page_id = -1\n    self.editor_version = editor_version\n    self.use_ssl = use_ssl\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.add_label","title":"<code>add_label(page_id, label_name)</code>","text":"<p>Add the given label to the given page Id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <code>label_name</code> <code>str</code> <p>label to be added</p> required <p>Returns:     True if successful</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def add_label(self, page_id: int, label_name: str) -&gt; bool:\n    \"\"\"\n    Add the given label to the given page Id\n\n    Args:\n        page_id: pageId\n        label_name: label to be added\n    Returns:\n        True if successful\n    \"\"\"\n    label_info = self.get_label_info(label_name)\n    if label_info.id &gt; 0:\n        prefix = label_info.prefix\n    else:\n        prefix = \"global\"\n\n    add_label_json = {\"prefix\": prefix, \"name\": label_name}\n\n    # Note: Keep using v1 API for labels as v2 API doesn't have equivalent endpoints\n    url = \"%s/rest/api/content/%d/label\" % (self.confluence_api_url, page_id)\n\n    response = self.get_session().post(url, data=json.dumps(add_label_json))\n    response.raise_for_status()\n    return True\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.check_errors_and_get_json","title":"<code>check_errors_and_get_json(response)</code>","text":"<p>Check the response for error codes</p> <p>Parameters:</p> Name Type Description Default <code>response </code> <p>The response from a request</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def check_errors_and_get_json(self, response: requests.Response) -&gt; CheckedResponse:\n    \"\"\"\n    Check the response for error codes\n\n    Args:\n        response : The response from a request\n\n    \"\"\"\n    try:\n        response.raise_for_status()\n    except requests.RequestException as err:\n        LOGGER.debug(\"err.response: %s\", err)\n        if response.status_code == 404:\n            return CheckedResponse(404, {\"error\": \"Not Found\"})\n        else:\n            LOGGER.error(\"Error: %d - %s\", response.status_code, response.content)\n            sys.exit(1)\n\n    return CheckedResponse(response.status_code, response.json())\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.create_page","title":"<code>create_page(title, body, parent_id)</code>","text":"<p>Create a new page</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>confluence page title</p> required <code>body</code> <code>str</code> <p>confluence page content</p> required <code>parent_id</code> <code>int</code> <p>confluence parentId</p> required <p>Returns:</p> Name Type Description <code>PageInfo</code> <code>PageInfo</code> <p>A named tuple with page information</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def create_page(self, title: str, body: str, parent_id: int) -&gt; PageInfo:\n    \"\"\"\n    Create a new page\n\n    Args:\n        title: confluence page title\n        body: confluence page content\n        parent_id: confluence parentId\n\n    Returns:\n        PageInfo: A named tuple with page information\n    \"\"\"\n    LOGGER.info(\"Creating page...\")\n\n    url = \"%s/api/v2/pages\" % self.confluence_api_url\n\n    space_id = self.get_space_id()\n\n    new_page = {\n        \"title\": title,\n        \"spaceId\": \"%d\" % space_id,\n        \"status\": \"current\",\n        \"body\": {\"value\": body, \"representation\": \"storage\"},\n        \"parentId\": \"%s\" % parent_id,\n    }\n\n    LOGGER.debug(\"data: %s\", json.dumps(new_page))\n\n    response = self.check_errors_and_get_json(\n        self.get_session().post(url, data=json.dumps(new_page))\n    )\n\n    if response.status_code == 200:\n        data = response.data\n        space_id = int(data[\"spaceId\"])\n        page_id = int(data[\"id\"])\n        version = data[\"version\"][\"number\"]\n        link = \"%s%s\" % (self.confluence_api_url, data[\"_links\"][\"webui\"])\n\n        LOGGER.info(\"Page created in SpaceId %d with ID: %d.\", space_id, page_id)\n        LOGGER.info(\"URL: %s\", link)\n\n        return PageInfo(page_id, space_id, version, link)\n    else:\n        LOGGER.error(\"Could not create page.\")\n        return PageInfo(0, 0, 0, \"\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.delete_page","title":"<code>delete_page(page_id)</code>","text":"<p>Delete a page</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def delete_page(self, page_id: int):\n    \"\"\"\n    Delete a page\n\n    Args:\n        page_id: confluence page id\n    \"\"\"\n    LOGGER.info(\"Deleting page...\")\n    url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n    response = self.get_session().delete(url)\n    response.raise_for_status()\n\n    if response.status_code == 204:\n        LOGGER.info(\"Page %d deleted successfully.\", page_id)\n    else:\n        LOGGER.error(\"Page %d could not be deleted.\", page_id)\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_attachment","title":"<code>get_attachment(page_id, filename)</code>","text":"<p>Get page attachment</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required <code>filename</code> <code>str</code> <p>attachment filename</p> required <p>Returns:     The attachment Id, or -1 if not found</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_attachment(self, page_id: int, filename: str) -&gt; str:\n    \"\"\"\n    Get page attachment\n\n    Args:\n        page_id: confluence page id\n        filename: attachment filename\n    Returns:\n        The attachment Id, or -1 if not found\n    \"\"\"\n    url = \"%s/api/v2/pages/%d/attachments?filename=%s\" % (\n        self.confluence_api_url,\n        page_id,\n        urllib.parse.quote_plus(filename),\n    )\n\n    response = self.check_errors_and_get_json(self.get_session().get(url))\n\n    if response.status_code == 404:\n        self.log_not_found(\n            \"Attachment\",\n            {PAGE_ID_KEY: \"%d\" % page_id, \"Filename\": filename}\n        )\n        return \"\"\n\n    if len(response.data[\"results\"]) &gt;= 1:\n        att_id = response.data[\"results\"][0][\"id\"]\n        return att_id\n\n    return \"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_folder","title":"<code>get_folder(folder_name)</code>","text":"<p>Get folder information for the given folder name</p> <p>Parameters:</p> Name Type Description Default <code>folder_name</code> <code>str</code> <p>Title of the folder to search for.</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def get_folder(self, folder_name: str) -&gt; int:\n    \"\"\"\n    Get folder information for the given folder name\n\n    Args:\n        folder_name: Title of the folder to search for.\n\n    \"\"\"\n\n    # This call populates self.space_home_page_id\n    self.get_space_id()\n\n    LOGGER.debug(\"\\tRetrieving folder information: %s\", folder_name)\n    url = \"%s/api/v2/pages/%d/descendants?depth=5\" % (\n        self.confluence_api_url,\n        self.space_home_page_id,\n    )\n\n    folder_id = 0\n\n    while True:\n        LOGGER.debug(\"Requesting URL for Folder: %s\", url)\n        response = self.check_errors_and_get_json(\n            self.get_session(retry=True).get(url)\n        )\n        if response.status_code == 404:\n            self.log_not_found(\n                \"Folder\", {\"Space Home Page Id\": \"%d\" % self.space_home_page_id}\n            )\n            break  # Exit the loop on 404\n\n        for item in response.data[\"results\"]:\n            if item[\"title\"] == folder_name and item[\"type\"] == \"folder\":\n                folder_id = int(item[\"id\"])\n                break\n\n        base = response.data.get(\"_links\", {}).get(\"base\", None)\n        url = response.data.get(\"_links\", {}).get(\"next\", None)\n\n        if not url:\n            break\n\n        if base:\n            base = base.replace(\"/wiki\", \"\")\n            url = urllib.parse.urljoin(base, url)\n\n    return folder_id\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_label_info","title":"<code>get_label_info(label_name)</code>","text":"<p>Get label information for the given label name</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>label name to search for</p> required <p>Returns:     LabelInfo.  If not found, labelInfo will be 0</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_label_info(self, label_name: str) -&gt; LabelInfo:\n    \"\"\"\n    Get label information for the given label name\n\n    Args:\n        label_name: label name to search for\n    Returns:\n        LabelInfo.  If not found, labelInfo will be 0\n    \"\"\"\n\n    LOGGER.debug(\"\\tRetrieving label information: %s\", label_name)\n    # Note: Keep using v1 API for labels as v2 API doesn't have equivalent endpoints\n    url = \"%s/rest/api/label?name=%s\" % (\n        self.confluence_api_url,\n        urllib.parse.quote_plus(label_name),\n    )\n\n    response = self.check_errors_and_get_json(self.get_session().get(url))\n\n    if response.status_code == 404:\n        label = LabelInfo(0, \"\", \"\", \"\")\n    else:\n        data = response.data[\"label\"]\n        label = LabelInfo(\n            int(data[\"id\"]),\n            data[\"name\"],\n            data[\"prefix\"],\n            data[\"label\"],\n        )\n\n    return label\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_page","title":"<code>get_page(title)</code>","text":"<p>Retrieve page details by title</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>page title</p> required <p>Returns:     Confluence page info</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_page(self, title: str) -&gt; PageInfo:\n    \"\"\"\n    Retrieve page details by title\n\n    Args:\n        title: page title\n    Returns:\n        Confluence page info\n    \"\"\"\n\n    space_id = self.get_space_id()\n\n    LOGGER.info(\"\\tRetrieving page information: %s\", title)\n    url = \"%s/api/v2/spaces/%d/pages?title=%s\" % (\n        self.confluence_api_url,\n        space_id,\n        urllib.parse.quote_plus(title),\n    )\n\n    response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n    if response.status_code == 404:\n        self.log_not_found(\"Page\", {\"Space Id\": \"%d\" % space_id})\n    else:\n        data = response.data\n\n        LOGGER.debug(\"data: %s\", str(data))\n\n        if len(data[\"results\"]) &gt;= 1:\n            page_id = int(data[\"results\"][0][\"id\"])\n            space_id = int(data[\"results\"][0][\"spaceId\"])\n            version_num = data[\"results\"][0][\"version\"][\"number\"]\n            link = \"%s%s\" % (\n                self.confluence_api_url,\n                data[\"results\"][0][\"_links\"][\"webui\"],\n            )\n\n            page = PageInfo(page_id, space_id, version_num, link)\n            return page\n\n    return PageInfo(0, 0, 0, \"\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_page_properties","title":"<code>get_page_properties(page_id)</code>","text":"<p>Retrieve page properties by page id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <p>Returns:     Page Properties Collection</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_page_properties(self, page_id: int) -&gt; typing.List[typing.Any]:\n    \"\"\"\n    Retrieve page properties by page id\n\n    Args:\n        page_id: pageId\n    Returns:\n        Page Properties Collection\n    \"\"\"\n\n    LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n    url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n\n    response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n    if response.status_code == 404:\n        self.log_not_found(\"Page Properties\", {PAGE_ID_KEY: \"%d\" % page_id})\n    else:\n        return response.data[\"results\"]\n\n    return []\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_session","title":"<code>get_session(retry=False, json=True)</code>","text":"<p>Retrieve a <code>requests</code> session object</p> <p>Parameters:</p> Name Type Description Default <code>retry</code> <code>bool</code> <p>Configure the request with a retry adapter.</p> <code>False</code> <code>json</code> <code>bool</code> <p>Configure the request to set Content-Type to 'application/json'</p> <code>True</code> <p>Returns:     requests.Session: A session from the <code>requests</code> module</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_session(self, retry: bool = False, json: bool = True) -&gt; requests.Session:\n    \"\"\"\n    Retrieve a `requests` session object\n\n    Args:\n        retry: Configure the request with a retry adapter.\n        json: Configure the request to set Content-Type to 'application/json'\n    Returns:\n        requests.Session: A session from the `requests` module\n\n    \"\"\"\n    session = requests.Session()\n    if retry:\n        retry_max_requests = 5\n        retry_backoff_factor = 0.1\n        retry_status_forcelist = (404, 500, 501, 502, 503, 504)\n        retry = requests.adapters.Retry(\n            total=retry_max_requests,\n            connect=retry_max_requests,\n            read=retry_max_requests,\n            backoff_factor=retry_backoff_factor,\n            status_forcelist=retry_status_forcelist,\n        )\n        adapter = requests.adapters.HTTPAdapter(max_retries=retry)\n        if self.use_ssl:\n            session.mount(\"https://\", adapter)\n        else:\n            session.mount(\"http://\", adapter)\n\n    session.auth = (self.user_name, self.api_key)\n    if json:\n        session.headers.update({\"Content-Type\": \"application/json\"})\n    return session\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_space_id","title":"<code>get_space_id()</code>","text":"<p>Retrieve the integer space ID for the current self.space_key</p> <p>Returns:</p> Type Description <code>int</code> <p>The integer ID for the space_key of this instance</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_space_id(self) -&gt; int:\n    \"\"\"\n    Retrieve the integer space ID for the current self.space_key\n\n    Returns:\n        The integer ID for the space_key of this instance\n\n    \"\"\"\n    if self.space_id &gt; -1:\n        return self.space_id\n\n    url = \"%s/api/v2/spaces?keys=%s\" % (self.confluence_api_url, self.space_key)\n\n    response = self.check_errors_and_get_json(self.get_session().get(url))\n\n    if response.status_code == 404:\n        self.log_not_found(\"Space\", {\"Space Key\": self.space_key})\n    else:\n        if len(response.data[\"results\"]) &gt;= 1:\n            self.space_id = int(response.data[\"results\"][0][\"id\"])\n            self.space_home_page_id = int(response.data[\"results\"][0][\"homepageId\"])\n\n    return self.space_id\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.log_not_found","title":"<code>log_not_found(object_name, log_values)</code>","text":"<p>Write a \"not found\" message to the LOGGER</p> <p>Parameters:</p> Name Type Description Default <code>object_name</code> <code>str</code> <p>The name to show in the log message</p> required <code>log_values</code> <code>dict[str, str]</code> <p>Additional key/value pairs to log</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def log_not_found(self, object_name: str, log_values: dict[str, str]):\n    \"\"\"\n    Write a \"not found\" message to the LOGGER\n\n    Args:\n        object_name: The name to show in the log message\n        log_values: Additional key/value pairs to log\n\n    \"\"\"\n    LOGGER.error(f\"{object_name} not found.\")\n    LOGGER.error(\"Diagnostic Information\")\n    LOGGER.error(f\"\\tURL: {self.confluence_api_url}\")\n    for key in log_values:\n        LOGGER.error(f\"\\t{key}: {log_values[key]}\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.update_labels","title":"<code>update_labels(page_id, labels)</code>","text":"<p>Update labels on given page Id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <code>labels</code> <code>List[str]</code> <p>labels to be added</p> required <p>Returns:     True if successful</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def update_labels(self, page_id: int, labels: typing.List[str]) -&gt; bool:\n    \"\"\"\n    Update labels on given page Id\n\n    Args:\n        page_id: pageId\n        labels: labels to be added\n    Returns:\n        True if successful\n    \"\"\"\n\n    LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n    url = \"%s/api/v2/pages/%d/labels\" % (self.confluence_api_url, page_id)\n\n    response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n    if response.status_code == 404:\n        LOGGER.error(\n            \"Error: Error finding existing labels. Check the following are correct:\"\n        )\n        LOGGER.error(\"\\t%s : %d\", PAGE_ID_KEY, page_id)\n        LOGGER.error(\"\\tURL: %s\", self.confluence_api_url)\n        return False\n\n    data = response.data\n    for label in labels:\n        found = False\n        for existing_label in data[\"results\"]:\n            if label == existing_label[\"name\"]:\n                found = True\n\n        if not found:\n            LOGGER.info(\"Adding Label '%s' to %s %d\", label, PAGE_ID_KEY, page_id)\n            self.add_label(page_id, label)\n\n        LOGGER.debug(\"property data: %s\", str(data[\"results\"]))\n\n    return data[\"results\"]\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.update_page","title":"<code>update_page(page_id, title, body, version, parent_id)</code>","text":"<p>Update a page</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required <code>title</code> <code>str</code> <p>confluence page title</p> required <code>body</code> <code>str</code> <p>confluence page content</p> required <code>version</code> <code>int</code> <p>confluence page version</p> required <code>parent_id</code> <code>int</code> <p>confluence parentId</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def update_page(\n    self, page_id: int, title: str, body: str, version: int, parent_id: int\n):\n    \"\"\"\n    Update a page\n\n    Args:\n        page_id: confluence page id\n        title: confluence page title\n        body: confluence page content\n        version: confluence page version\n        parent_id: confluence parentId\n    \"\"\"\n    LOGGER.info(\"Updating page...\")\n\n    url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n    page_json = {\n        \"id\": page_id,\n        \"type\": \"page\",\n        \"title\": title,\n        \"spaceId\": \"%s\" % self.get_space_id(),\n        \"status\": \"current\",\n        \"body\": {\"value\": body, \"representation\": \"storage\"},\n        \"version\": {\"number\": version + 1, \"minorEdit\": True},\n        \"parentId\": \"%s\" % parent_id,\n    }\n\n    session = self.get_session()\n    response = self.check_errors_and_get_json(\n        session.put(url, data=json.dumps(page_json))\n    )\n\n    if response.status_code == 404:\n        self.log_not_found(\"Page\", {PAGE_ID_KEY: \"%d\" % page_id})\n        return False\n\n    if response.status_code == 200:\n        link = \"%s%s\" % (self.confluence_api_url, response.data[\"_links\"][\"webui\"])\n        LOGGER.info(\"Page updated successfully.\")\n        LOGGER.info(\"URL: %s\", link)\n        return True\n    else:\n        LOGGER.error(\"Page could not be updated.\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.update_page_property","title":"<code>update_page_property(page_id, page_property)</code>","text":"<p>Update page property by page id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <p>Returns:     True if successful</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def update_page_property(self, page_id: int, page_property) -&gt; bool:\n    \"\"\"\n    Update page property by page id\n\n    Args:\n        page_id: pageId\n    Returns:\n        True if successful\n    \"\"\"\n\n    property_json = {\n        \"page-id\": page_id,\n        \"key\": page_property[\"key\"],\n        \"value\": page_property[\"value\"],\n        \"version\": {\"number\": page_property[\"version\"], \"minorEdit\": True},\n    }\n\n    if \"id\" in page_property:\n        url = \"%s/api/v2/pages/%d/properties/%s\" % (\n            self.confluence_api_url,\n            page_id,\n            page_property[\"id\"],\n        )\n        property_json.update({\"property-id\": page_property[\"id\"]})\n        LOGGER.info(\n            \"Updating Property ID %s on Page %d: %s=%s\",\n            property_json[\"property-id\"],\n            page_id,\n            property_json[\"key\"],\n            property_json[\"value\"],\n        )\n        response = self.check_errors_and_get_json(\n            self.get_session(retry=True).put(url, data=json.dumps(property_json))\n        )\n    else:\n        url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n        LOGGER.info(\n            \"Adding Property to Page %s: %s=%s\",\n            page_id,\n            property_json[\"key\"],\n            property_json[\"value\"],\n        )\n        response = self.check_errors_and_get_json(\n            self.get_session(retry=True).post(url, data=json.dumps(property_json))\n        )\n\n    if response.status_code != 200:\n        LOGGER.error(\n            \"Unable to add property %s to page %d\", property_json[\"key\"], page_id\n        )\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.upload_attachment","title":"<code>upload_attachment(page_id, file, comment)</code>","text":"<p>Upload an attachement</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required <code>file</code> <code>str</code> <p>attachment file</p> required <code>comment</code> <code>str</code> <p>attachment comment</p> required <p>Returns:     True if successful, false otherwise</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def upload_attachment(self, page_id: int, file: str, comment: str) -&gt; bool:\n    \"\"\"\n    Upload an attachement\n\n    Args:\n        page_id: confluence page id\n        file: attachment file\n        comment: attachment comment\n    Returns:\n        True if successful, false otherwise\n    \"\"\"\n    if re.search(r\"http.*\", file):\n        return False\n\n    content_type = mimetypes.guess_type(file)[0]\n    filename = os.path.basename(file)\n\n    if not os.path.isfile(file):\n        LOGGER.error(\"File %s cannot be found --&gt; skip \", file)\n        return False\n\n    file_to_upload = {\n        \"comment\": comment,\n        \"file\": (filename, open(file, \"rb\"), content_type, {\"Expires\": \"0\"}),\n    }\n\n    attachment_id = self.get_attachment(page_id, filename)\n    if attachment_id != \"\":\n        # Update existing attachment using v2 API\n        url = \"%s/rest/api/content/%d/child/attachment/%s/data\" % (\n            self.confluence_api_url,\n            page_id,\n            attachment_id,\n        )\n    else:\n        # Create new attachment using v2 API\n        url = \"%s/rest/api/content/%d/child/attachment/\" % (\n            self.confluence_api_url,\n            page_id,\n        )\n\n    session = self.get_session(json=False)\n    session.headers.update({\"X-Atlassian-Token\": \"no-check\"})\n\n    LOGGER.info(\"\\tUploading attachment %s...\", filename)\n\n    response = session.post(url, files=file_to_upload)\n    response.raise_for_status()\n\n    return True\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo","title":"<code>LabelInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>NamedTuple containing label information</p> Source code in <code>md_to_conf/client.py</code> <pre><code>class LabelInfo(typing.NamedTuple):\n    \"\"\"\n    NamedTuple containing label information\n\n    \"\"\"\n\n    id: int\n    \"\"\" Label Id \"\"\"\n\n    name: str\n    \"\"\" The name of the label \"\"\"\n\n    prefix: str\n    \"\"\" The prefix of the label \"\"\"\n\n    label: str\n    \"\"\" The translated label \"\"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>Label Id</p>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.label","title":"<code>label</code>  <code>instance-attribute</code>","text":"<p>The translated label</p>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>The name of the label</p>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.prefix","title":"<code>prefix</code>  <code>instance-attribute</code>","text":"<p>The prefix of the label</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo","title":"<code>PageInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>NamedTuple containing page information</p> Source code in <code>md_to_conf/client.py</code> <pre><code>class PageInfo(typing.NamedTuple):\n    \"\"\"\n    NamedTuple containing page information\n\n    \"\"\"\n\n    id: int\n    \"\"\" Page Id \"\"\"\n\n    spaceId: int\n    \"\"\" Space Id \"\"\"\n\n    version: int\n    \"\"\" Page Version \"\"\"\n\n    link: str\n    \"\"\" Page Link \"\"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.id","title":"<code>id</code>  <code>instance-attribute</code>","text":"<p>Page Id</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.link","title":"<code>link</code>  <code>instance-attribute</code>","text":"<p>Page Link</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.spaceId","title":"<code>spaceId</code>  <code>instance-attribute</code>","text":"<p>Space Id</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.version","title":"<code>version</code>  <code>instance-attribute</code>","text":"<p>Page Version</p>"},{"location":"api/converter-reference/","title":"Converter","text":""},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter","title":"<code>MarkdownConverter</code>","text":"<p>Wrapper for the <code>markdown</code> module that converts Markdown into HTML</p> <p>Provides some additional functions for advanced HTML processing</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>class MarkdownConverter:\n    \"\"\"\n    Wrapper for the `markdown` module that converts Markdown into HTML\n\n    Provides some additional functions for advanced HTML processing\n\n    \"\"\"\n\n    def __init__(self, md_file: str, api_url: str, md_source: str, editor_version: int):\n        \"\"\"\n        Constructor\n\n        Args:\n            md_file: Path the the Markdown file\n            api_url: Path the the Confluence API, used to build link urls\n            md_source: MD Source format: current choices are `default` and `bitbucket`\n            editor_version: Version to use for the editor\n        \"\"\"\n        self.md_file = md_file\n        self.api_url = api_url\n        self.md_source = md_source\n        self.editor_version = editor_version\n\n    def convert_md_to_conf_html(\n        self,\n        has_title: bool = False,\n        remove_emojies: bool = False,\n        add_contents: bool = False,\n    ):\n        \"\"\"\n        Convert the Markdown file to Confluence HTML\n\n        Args:\n            has_title: Was a title provided via the CLI?\n            remove_emojies: Should emojies be removed?\n            add_contents: Should a contents section be added to the page\n\n        Returns:\n            A string representing HTML for the Markdown page\n        \"\"\"\n        html = self.get_html_from_markdown()\n        if not has_title:\n            html = \"\\n\".join(html.split(\"\\n\")[1:])\n\n        LOGGER.debug(\"HTML pre processing\")\n        LOGGER.debug(html)\n        html = self.create_table_of_content(html)\n        html = self.convert_info_macros(html)\n        html = self.convert_comment_block(html)\n        html = self.convert_code_block(html)\n\n        if remove_emojies:\n            html = self.remove_emojies(html)\n\n        if add_contents:\n            html = self.add_contents(html)\n\n        html = self.process_refs(html)\n        return html\n\n    def get_html_from_markdown(self) -&gt; str:\n        \"\"\"\n        Convert the Markdown file to HTML.  This is a wrapper\n        around the markdown library\n\n        Returns:\n            A string representing HTML for the Markdown page\n        \"\"\"\n        with codecs.open(self.md_file, \"r\", \"utf-8\") as mdfile:\n            markdown_content = mdfile.read()\n            html = markdown.markdown(\n                markdown_content,\n                extensions=[\n                    \"tables\",\n                    \"fenced_code\",\n                    \"footnotes\",\n                    \"mdx_truly_sane_lists\",\n                ],\n            )\n\n        return html\n\n    def convert_comment_block(self, html: str) -&gt; str:\n        \"\"\"\n        Convert markdown code bloc to Confluence hidden comment\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        open_tag = \"&lt;ac:placeholder&gt;\"\n        close_tag = \"&lt;/ac:placeholder&gt;\"\n        html = html.replace(\"&lt;!--\", open_tag).replace(\"--&gt;\", close_tag)\n        return html\n\n    def create_table_of_content(self, html: str) -&gt; str:\n        \"\"\"\n        Check for the string '[TOC]' and replaces it the\n        Confluence \"Table of Content\" macro\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        html = str.replace(\n            html,\n            r\"&lt;p&gt;[TOC]&lt;/p&gt;\",\n            '&lt;p&gt;&lt;ac:structured-macro ac:name=\"toc-zone\" ac:schema-version=\"1\" '\n            'data-layout=\"default\"&gt;&lt;ac:rich-text-body&gt;&lt;ac:structured-macro '\n            'ac:name=\"toc\" ac:schema-version=\"1\" data-layout=\"default\"/&gt;'\n            '&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;&lt;/p&gt;',\n        )\n\n        return html\n\n    def convert_code_block(self, html: str) -&gt; str:\n        \"\"\"\n        Convert html code blocks to Confluence macros\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        LOGGER.debug(\"HTML pre code block\")\n        LOGGER.debug(html)\n        code_blocks = re.findall(r\"&lt;pre&gt;&lt;code.*?&gt;.*?&lt;/code&gt;&lt;/pre&gt;\", html, re.DOTALL)\n        if code_blocks:\n            for tag in code_blocks:\n                conf_ml = '&lt;ac:structured-macro ac:name=\"code\"&gt;'\n                conf_ml = (\n                    conf_ml + '&lt;ac:parameter ac:name=\"theme\"&gt;Midnight&lt;/ac:parameter&gt;'\n                )\n                conf_ml = (\n                    conf_ml + '&lt;ac:parameter ac:name=\"linenumbers\"&gt;true&lt;/ac:parameter&gt;'\n                )\n\n                lang = re.search('code class=\"language-(.*)\"', tag)\n                if lang:\n                    lang = lang.group(1)\n                else:\n                    lang = \"none\"\n\n                conf_ml = (\n                    conf_ml\n                    + '&lt;ac:parameter ac:name=\"language\"&gt;'\n                    + lang\n                    + \"&lt;/ac:parameter&gt;\"\n                )\n                content = re.search(\n                    r\"&lt;pre&gt;&lt;code.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;\", tag, re.DOTALL\n                ).group(1)\n                content = (\n                    \"&lt;ac:plain-text-body&gt;&lt;![CDATA[\"\n                    + content\n                    + \"]]&gt;&lt;/ac:plain-text-body&gt;\"\n                )\n                conf_ml = conf_ml + content + \"&lt;/ac:structured-macro&gt;\"\n                conf_ml = conf_ml.replace(\"&amp;lt;\", \"&lt;\").replace(\"&amp;gt;\", \"&gt;\")\n                conf_ml = conf_ml.replace(\"&amp;quot;\", '\"').replace(\"&amp;amp;\", \"&amp;\")\n\n                html = html.replace(tag, conf_ml)\n\n        return html\n\n    def remove_emojies(self, html: str) -&gt; str:\n        \"\"\"\n        Remove emojies if there are any\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        regrex_pattern = re.compile(\n            pattern=\"[\"\n            \"\\U0001f600-\\U0001f64f\"  # emoticons\n            \"\\U0001f300-\\U0001f5ff\"  # symbols &amp; pictographs\n            \"\\U0001f680-\\U0001f6ff\"  # transport &amp; map symbols\n            \"\\U0001f1e0-\\U0001f1ff\"  # flags (iOS)\n            \"]+\",\n            flags=re.UNICODE,\n        )\n        return regrex_pattern.sub(r\"\", html)\n\n    def convert_github_alerts(self, html: str) -&gt; str:\n        \"\"\"\n        Convert GitHub-flavored markdown alert boxes to Confluence macros\n\n        Supports GitHub alert syntax:\n        &gt; [!NOTE] Content\n        &gt; [!TIP] Content\n        &gt; [!IMPORTANT] Content\n        &gt; [!WARNING] Content\n        &gt; [!CAUTION] Content\n\n        Args:\n            html: html string\n        Returns:\n            modified html string with GitHub alerts converted to Confluence macros\n        \"\"\"\n        # Find all blockquotes that might contain GitHub alerts\n        blockquotes = re.findall(r\"&lt;blockquote&gt;(.*?)&lt;/blockquote&gt;\", html, re.DOTALL)\n\n        for quote in blockquotes:\n            parsed_alert = self._parse_github_alert(quote)\n            if parsed_alert:\n                replacement_macro = self._create_alert_macro(parsed_alert)\n                if replacement_macro:\n                    html = html.replace(\n                        f\"&lt;blockquote&gt;{quote}&lt;/blockquote&gt;\", replacement_macro\n                    )\n\n        return html\n\n    def _parse_github_alert(self, quote: str) -&gt; typing.Optional[dict]:\n        \"\"\"\n        Parse a blockquote to extract GitHub alert information.\n\n        Args:\n            quote: The blockquote content\n\n        Returns:\n            Dictionary with alert info if valid GitHub alert, None otherwise\n        \"\"\"\n        if not quote.strip().startswith(\"&lt;p&gt;[!\"):\n            return None\n\n        # Extract alert type\n        alert_match = re.search(\n            r\"&lt;p&gt;\\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\\]\", quote, re.IGNORECASE\n        )\n        if not alert_match:\n            return None\n\n        alert_type = alert_match.group(1).upper()\n\n        # Find the content after the alert declaration\n        content_start = alert_match.end()\n        first_p_end = quote.find(\"&lt;/p&gt;\", content_start)\n\n        if first_p_end == -1:\n            return None\n\n        # Extract first line content and remaining content\n        first_line_content = quote[content_start:first_p_end].strip()\n        remaining_content = quote[first_p_end + 4 :].strip()  # Skip '&lt;/p&gt;'\n\n        return {\n            \"alert_type\": alert_type,\n            \"first_line_content\": first_line_content,\n            \"remaining_content\": remaining_content,\n        }\n\n    def _get_alert_macro_tags(self, alert_type: str) -&gt; typing.Optional[tuple]:\n        \"\"\"\n        Get the appropriate Confluence macro tags for the given alert type.\n\n        Args:\n            alert_type: The GitHub alert type (NOTE, TIP, etc.)\n\n        Returns:\n            Tuple of (opening_tag, closing_tag) or None if unknown type\n        \"\"\"\n        # Define Confluence macro tags\n        info_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"info\"&gt;&lt;ac:rich-text-body&gt;'\n        tip_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"tip\"&gt;&lt;ac:rich-text-body&gt;'\n        warning_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"note\"&gt;&lt;ac:rich-text-body&gt;'\n        error_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"warning\"&gt;&lt;ac:rich-text-body&gt;'\n        close_tag = \"&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;&lt;/p&gt;\"\n\n        # Special note tag for IMPORTANT alerts (using ADF panel format)\n        note_tag = ('&lt;ac:adf-extension&gt;&lt;ac:adf-node type=\"panel\"&gt;'\n                    '&lt;ac:adf-attribute key=\"panel-type\"&gt;note&lt;/ac:adf-attribute&gt;'\n                    '&lt;ac:adf-content&gt;')\n        note_close = \"&lt;/ac:adf-content&gt;&lt;/ac:adf-node&gt;&lt;/ac:adf-extension&gt;\"\n\n        alert_mapping = {\n            \"NOTE\": (info_tag, close_tag),\n            \"TIP\": (tip_tag, close_tag),\n            \"IMPORTANT\": (note_tag, note_close),\n            \"WARNING\": (warning_tag, close_tag),\n            \"CAUTION\": (error_tag, close_tag),\n        }\n\n        return alert_mapping.get(alert_type)\n\n    def _build_alert_content(\n        self, first_line_content: str, remaining_content: str\n    ) -&gt; str:\n        \"\"\"\n        Build the final content for the alert macro.\n\n        Args:\n            first_line_content: Content from the first line after alert declaration\n            remaining_content: Any remaining content in the blockquote\n\n        Returns:\n            Formatted content string\n        \"\"\"\n        content_parts = []\n        if first_line_content:\n            content_parts.append(f\"&lt;p&gt;{first_line_content}&lt;/p&gt;\")\n        if remaining_content:\n            content_parts.append(remaining_content)\n\n        final_content = \"\".join(content_parts)\n        return final_content if final_content else \"&lt;p&gt;&lt;/p&gt;\"\n\n    def _create_alert_macro(self, alert_info: dict) -&gt; typing.Optional[str]:\n        \"\"\"\n        Create a Confluence macro from parsed GitHub alert information.\n\n        Args:\n            alert_info: Dictionary containing alert type and content\n\n        Returns:\n            Confluence macro string or None if unknown alert type\n        \"\"\"\n        macro_tags = self._get_alert_macro_tags(alert_info[\"alert_type\"])\n        if not macro_tags:\n            return None  # Unknown alert type\n\n        macro_tag, close_macro_tag = macro_tags\n        final_content = self._build_alert_content(\n            alert_info[\"first_line_content\"], alert_info[\"remaining_content\"]\n        )\n\n        return macro_tag + final_content + close_macro_tag\n\n    def convert_info_macros(self, html: str) -&gt; str:\n        \"\"\"\n        Converts html for info, note or warning macros\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n        # First, convert GitHub-flavored markdown alerts (takes precedence)\n        html = self.convert_github_alerts(html)\n\n        info_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"info\"&gt;&lt;ac:rich-text-body&gt;&lt;p&gt;'\n        # Warning (Yellow Caution Icon) is named 'note' in Confluence\n        warning_tag = info_tag.replace(\"info\", \"note\")\n        # Success (Green Check Icon) is named 'tip' in Confluence\n        success_tag = info_tag.replace(\"info\", \"tip\")\n        # Error (Red Cross Icon) is named 'warning' in Confluence\n        error_tag = info_tag.replace(\"info\", \"warning\")\n        close_tag = \"&lt;/p&gt;&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;&lt;/p&gt;\"\n\n        note_tag = ('&lt;ac:adf-extension&gt;&lt;ac:adf-node type=\"panel\"&gt;'\n                    '&lt;ac:adf-attribute key=\"panel-type\"&gt;note&lt;/ac:adf-attribute&gt;'\n                    '&lt;ac:adf-content&gt;&lt;p&gt;')\n        note_close = '&lt;/p&gt;&lt;/ac:adf-content&gt;&lt;/ac:adf-node&gt;&lt;/ac:adf-extension&gt;'\n\n        # Custom tags converted into macros\n        html = html.replace(\"&lt;p&gt;~?\", info_tag).replace(\"?~&lt;/p&gt;\", close_tag)\n        html = html.replace(\"&lt;p&gt;~%\", warning_tag).replace(\"%~&lt;/p&gt;\", close_tag)\n        html = html.replace(\"&lt;p&gt;~^\", success_tag).replace(\"^~&lt;/p&gt;\", close_tag)\n        html = html.replace(\"&lt;p&gt;~$\", error_tag).replace(\"$~&lt;/p&gt;\", close_tag)\n\n        html = html.replace(\"&lt;p&gt;~!\", note_tag).replace(\"!~&lt;/p&gt;\", note_close)\n\n        # Convert block quotes into macros\n        quotes = re.findall(\"&lt;blockquote&gt;(.*?)&lt;/blockquote&gt;\", html, re.DOTALL)\n        if quotes:\n            for quote in quotes:\n                note = re.search(\"^&lt;.*&gt;Note\", quote.strip(), re.IGNORECASE)\n                warning = re.search(\"^&lt;.*&gt;Warning\", quote.strip(), re.IGNORECASE)\n                success = re.search(\"^&lt;.*&gt;Success\", quote.strip(), re.IGNORECASE)\n                error = re.search(\"^&lt;.*&gt;Error\", quote.strip(), re.IGNORECASE)\n\n                if note:\n                    clean_tag = self.strip_type(quote, \"Note\")\n                    macro_tag = (\n                        clean_tag.replace(\"&lt;p&gt;\", note_tag)\n                        .replace(\"&lt;/p&gt;\", note_close)\n                        .strip()\n                    )\n                elif warning:\n                    clean_tag = self.strip_type(quote, \"Warning\")\n                    macro_tag = (\n                        clean_tag.replace(\"&lt;p&gt;\", warning_tag)\n                        .replace(\"&lt;/p&gt;\", close_tag)\n                        .strip()\n                    )\n                elif success:\n                    clean_tag = self.strip_type(quote, \"Success\")\n                    macro_tag = (\n                        clean_tag.replace(\"&lt;p&gt;\", success_tag)\n                        .replace(\"&lt;/p&gt;\", close_tag)\n                        .strip()\n                    )\n                elif error:\n                    clean_tag = self.strip_type(quote, \"Error\")\n                    macro_tag = (\n                        clean_tag.replace(\"&lt;p&gt;\", error_tag)\n                        .replace(\"&lt;/p&gt;\", close_tag)\n                        .strip()\n                    )\n                else:\n                    macro_tag = (\n                        quote.replace(\"&lt;p&gt;\", info_tag)\n                        .replace(\"&lt;/p&gt;\", close_tag)\n                        .strip()\n                    )\n\n                html = html.replace(\"&lt;blockquote&gt;%s&lt;/blockquote&gt;\" % quote, macro_tag)\n\n        # Convert doctoc to toc confluence macro\n        html = self.convert_doctoc(html)\n\n        return html\n\n    def convert_doctoc(self, html: str) -&gt; str:\n        \"\"\"\n        Convert doctoc to confluence macro\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n\n        toc_tag = \"\"\"&lt;p&gt;\n        &lt;ac:structured-macro ac:name=\"toc\"&gt;\n        &lt;ac:parameter ac:name=\"printable\"&gt;true&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"maxLevel\"&gt;7&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"outline\"&gt;clear&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"include\"&gt;.*&lt;/ac:parameter&gt;\n        &lt;/ac:structured-macro&gt;\n        &lt;/p&gt;\"\"\"\n\n        html = re.sub(\n            r\"\\&lt;\\!\\-\\- START doctoc.*END doctoc \\-\\-\\&gt;\", toc_tag, html, flags=re.DOTALL\n        )\n\n        return html\n\n    def strip_type(self, tag: str, tagtype: str) -&gt; str:\n        \"\"\"\n        Strips Note or Warning tags from html in various formats\n\n        Args:\n            tag: tag name\n            tagtype: tag type\n        Returns:\n            modified tag\n        \"\"\"\n        tag = re.sub(r\"%s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n        tag = re.sub(r\"%s\\s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n        tag = re.sub(r\"&lt;.*?&gt;%s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;.*?&gt;%s\\s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        string_start = re.search(\"&lt;[^&gt;]*&gt;\", tag)\n        tag = self.upper_chars(tag, [string_start.end()])\n        return tag\n\n    def upper_chars(self, string: str, indices: typing.List[int]) -&gt; str:\n        \"\"\"\n        Make characters uppercase in string\n\n        Args:\n            string: string to modify\n            indices: character indice to change to uppercase\n        Returns:\n            uppercased string\n        \"\"\"\n        upper_string = \"\".join(\n            c.upper() if i in indices else c for i, c in enumerate(string)\n        )\n        return upper_string\n\n    def slug(self, string: str, lowercase: bool) -&gt; str:\n        \"\"\"\n        Creates a slug string\n\n        Args:\n            string: string to modify\n            lowercase: whether string has to be lowercased\n        Returns:\n            slug string\n        \"\"\"\n\n        slug_string = string\n        if lowercase:\n            slug_string = string.lower()\n\n        # Remove all html code tags\n        slug_string = re.sub(r\"&lt;[^&gt;]+&gt;\", \"\", slug_string)\n        # Remove html code like '&amp;amp;'\n        slug_string = re.sub(r\"&amp;[a-z]+;\", \"\", slug_string)\n        # Replace all spaces ( ) with dash (-)\n        slug_string = str.replace(slug_string, \" \", \"-\")\n\n        # Remove all special chars, except for dash (-)\n        slug_string = re.sub(r\"[^a-zA-Z0-9-]\", \"\", slug_string)\n\n        return slug_string\n\n    def process_headers(self, ref_prefix, ref_postfix, headers):\n        headers_map = {}\n        headers_count = {}\n\n        for header in headers:\n            key = ref_prefix + self.slug(header, True)\n\n            if self.editor_version == 1:\n                value = re.sub(r\"(&lt;.+&gt;| )\", \"\", header)\n            if self.editor_version == 2:\n                value = self.slug(header, False)\n\n            if key in headers_map:\n                alt_count = headers_count[key]\n\n                alt_key = key + (ref_postfix % alt_count)\n                alt_value = value + (\".%s\" % alt_count)\n\n                headers_map[alt_key] = alt_value\n                headers_count[key] = alt_count + 1\n            else:\n                headers_map[key] = value\n                headers_count[key] = 1\n\n        return headers_map\n\n    def process_links(\n        self, html, links, headers_map, space_key: str, page_id: int, title: str\n    ):\n        for link in links:\n            matches = re.search(r'&lt;a href=\"(#.+?)\"&gt;(.+?)&lt;/a&gt;', link)\n            ref = matches.group(1)\n            alt = matches.group(2)\n\n            result_ref = headers_map.get(ref)\n\n            if result_ref:\n                base_uri = \"%s/spaces/%s/pages/%d/%s\" % (\n                    self.api_url,\n                    space_key,\n                    page_id,\n                    \"+\".join(title.split()),\n                )\n                if self.editor_version == 1:\n                    replacement = (\n                        '&lt;ac:link ac:anchor=\"%s\"&gt;'\n                        \"&lt;ac:plain-text-link-body&gt;\"\n                        \"&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-link-body&gt;&lt;/ac:link&gt;\"\n                        % (result_ref, re.sub(r\"( *&lt;.+&gt; *)\", \" \", alt))\n                    )\n                if self.editor_version == 2:\n                    replacement_uri = \"%s#%s\" % (base_uri, result_ref)\n                    replacement = '&lt;a href=\"%s\" title=\"%s\"&gt;%s&lt;/a&gt;' % (\n                        replacement_uri,\n                        alt,\n                        alt,\n                    )\n\n                LOGGER.debug(\"Replacing link %s with %s\", link, replacement)\n                html = html.replace(link, replacement)\n\n        return html\n\n    def process_refs(self, html: str) -&gt; str:\n        \"\"\"\n        Process references\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n        refs = re.findall(r\"\\n(\\[\\^(\\d)\\].*)|&lt;p&gt;(\\[\\^(\\d)\\].*)\", html)\n\n        if refs:\n            for ref in refs:\n                if ref[0]:\n                    full_ref = ref[0].replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n                    ref_id = ref[1]\n                else:\n                    full_ref = ref[2]\n                    ref_id = ref[3]\n\n                full_ref = full_ref.replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n                html = html.replace(full_ref, \"\")\n                href = re.search('href=\"(.*?)\"', full_ref).group(1)\n\n                superscript = '&lt;a id=\"test\" href=\"%s\"&gt;&lt;sup&gt;%s&lt;/sup&gt;&lt;/a&gt;' % (\n                    href,\n                    ref_id,\n                )\n                html = html.replace(\"[^%s]\" % ref_id, superscript)\n\n        return html\n\n    # Scan for images and upload as attachments if found\n\n    def add_contents(self, html: str) -&gt; str:\n        \"\"\"\n        Add contents page\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n        contents_markup = (\n            '&lt;ac:structured-macro ac:name=\"toc\"&gt;\\n&lt;ac:parameter ac:name=\"printable\"&gt;'\n            'true&lt;/ac:parameter&gt;\\n&lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;'\n        )\n        contents_markup = (\n            contents_markup + '&lt;ac:parameter ac:name=\"maxLevel\"&gt;5&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;'\n        )\n        contents_markup = (\n            contents_markup\n            + '&lt;ac:parameter ac:name=\"class\"&gt;rm-contents&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"exclude\"&gt;&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;'\n        )\n        contents_markup = (\n            contents_markup + '&lt;ac:parameter ac:name=\"outline\"&gt;false&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"include\"&gt;&lt;/ac:parameter&gt;\\n'\n            \"&lt;/ac:structured-macro&gt;\"\n        )\n\n        html = contents_markup + \"\\n\" + html\n        return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.__init__","title":"<code>__init__(md_file, api_url, md_source, editor_version)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>md_file</code> <code>str</code> <p>Path the the Markdown file</p> required <code>api_url</code> <code>str</code> <p>Path the the Confluence API, used to build link urls</p> required <code>md_source</code> <code>str</code> <p>MD Source format: current choices are <code>default</code> and <code>bitbucket</code></p> required <code>editor_version</code> <code>int</code> <p>Version to use for the editor</p> required Source code in <code>md_to_conf/converter.py</code> <pre><code>def __init__(self, md_file: str, api_url: str, md_source: str, editor_version: int):\n    \"\"\"\n    Constructor\n\n    Args:\n        md_file: Path the the Markdown file\n        api_url: Path the the Confluence API, used to build link urls\n        md_source: MD Source format: current choices are `default` and `bitbucket`\n        editor_version: Version to use for the editor\n    \"\"\"\n    self.md_file = md_file\n    self.api_url = api_url\n    self.md_source = md_source\n    self.editor_version = editor_version\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.add_contents","title":"<code>add_contents(html)</code>","text":"<p>Add contents page</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def add_contents(self, html: str) -&gt; str:\n    \"\"\"\n    Add contents page\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n    contents_markup = (\n        '&lt;ac:structured-macro ac:name=\"toc\"&gt;\\n&lt;ac:parameter ac:name=\"printable\"&gt;'\n        'true&lt;/ac:parameter&gt;\\n&lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;'\n    )\n    contents_markup = (\n        contents_markup + '&lt;ac:parameter ac:name=\"maxLevel\"&gt;5&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;'\n    )\n    contents_markup = (\n        contents_markup\n        + '&lt;ac:parameter ac:name=\"class\"&gt;rm-contents&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"exclude\"&gt;&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;'\n    )\n    contents_markup = (\n        contents_markup + '&lt;ac:parameter ac:name=\"outline\"&gt;false&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"include\"&gt;&lt;/ac:parameter&gt;\\n'\n        \"&lt;/ac:structured-macro&gt;\"\n    )\n\n    html = contents_markup + \"\\n\" + html\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_code_block","title":"<code>convert_code_block(html)</code>","text":"<p>Convert html code blocks to Confluence macros</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_code_block(self, html: str) -&gt; str:\n    \"\"\"\n    Convert html code blocks to Confluence macros\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    LOGGER.debug(\"HTML pre code block\")\n    LOGGER.debug(html)\n    code_blocks = re.findall(r\"&lt;pre&gt;&lt;code.*?&gt;.*?&lt;/code&gt;&lt;/pre&gt;\", html, re.DOTALL)\n    if code_blocks:\n        for tag in code_blocks:\n            conf_ml = '&lt;ac:structured-macro ac:name=\"code\"&gt;'\n            conf_ml = (\n                conf_ml + '&lt;ac:parameter ac:name=\"theme\"&gt;Midnight&lt;/ac:parameter&gt;'\n            )\n            conf_ml = (\n                conf_ml + '&lt;ac:parameter ac:name=\"linenumbers\"&gt;true&lt;/ac:parameter&gt;'\n            )\n\n            lang = re.search('code class=\"language-(.*)\"', tag)\n            if lang:\n                lang = lang.group(1)\n            else:\n                lang = \"none\"\n\n            conf_ml = (\n                conf_ml\n                + '&lt;ac:parameter ac:name=\"language\"&gt;'\n                + lang\n                + \"&lt;/ac:parameter&gt;\"\n            )\n            content = re.search(\n                r\"&lt;pre&gt;&lt;code.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;\", tag, re.DOTALL\n            ).group(1)\n            content = (\n                \"&lt;ac:plain-text-body&gt;&lt;![CDATA[\"\n                + content\n                + \"]]&gt;&lt;/ac:plain-text-body&gt;\"\n            )\n            conf_ml = conf_ml + content + \"&lt;/ac:structured-macro&gt;\"\n            conf_ml = conf_ml.replace(\"&amp;lt;\", \"&lt;\").replace(\"&amp;gt;\", \"&gt;\")\n            conf_ml = conf_ml.replace(\"&amp;quot;\", '\"').replace(\"&amp;amp;\", \"&amp;\")\n\n            html = html.replace(tag, conf_ml)\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_comment_block","title":"<code>convert_comment_block(html)</code>","text":"<p>Convert markdown code bloc to Confluence hidden comment</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_comment_block(self, html: str) -&gt; str:\n    \"\"\"\n    Convert markdown code bloc to Confluence hidden comment\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    open_tag = \"&lt;ac:placeholder&gt;\"\n    close_tag = \"&lt;/ac:placeholder&gt;\"\n    html = html.replace(\"&lt;!--\", open_tag).replace(\"--&gt;\", close_tag)\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_doctoc","title":"<code>convert_doctoc(html)</code>","text":"<p>Convert doctoc to confluence macro</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_doctoc(self, html: str) -&gt; str:\n    \"\"\"\n    Convert doctoc to confluence macro\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n\n    toc_tag = \"\"\"&lt;p&gt;\n    &lt;ac:structured-macro ac:name=\"toc\"&gt;\n    &lt;ac:parameter ac:name=\"printable\"&gt;true&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"maxLevel\"&gt;7&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"outline\"&gt;clear&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"include\"&gt;.*&lt;/ac:parameter&gt;\n    &lt;/ac:structured-macro&gt;\n    &lt;/p&gt;\"\"\"\n\n    html = re.sub(\n        r\"\\&lt;\\!\\-\\- START doctoc.*END doctoc \\-\\-\\&gt;\", toc_tag, html, flags=re.DOTALL\n    )\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_github_alerts","title":"<code>convert_github_alerts(html)</code>","text":"<p>Convert GitHub-flavored markdown alert boxes to Confluence macros</p> <p>Supports GitHub alert syntax:</p> <p>[!NOTE] Content [!TIP] Content [!IMPORTANT] Content [!WARNING] Content [!CAUTION] Content</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string with GitHub alerts converted to Confluence macros</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_github_alerts(self, html: str) -&gt; str:\n    \"\"\"\n    Convert GitHub-flavored markdown alert boxes to Confluence macros\n\n    Supports GitHub alert syntax:\n    &gt; [!NOTE] Content\n    &gt; [!TIP] Content\n    &gt; [!IMPORTANT] Content\n    &gt; [!WARNING] Content\n    &gt; [!CAUTION] Content\n\n    Args:\n        html: html string\n    Returns:\n        modified html string with GitHub alerts converted to Confluence macros\n    \"\"\"\n    # Find all blockquotes that might contain GitHub alerts\n    blockquotes = re.findall(r\"&lt;blockquote&gt;(.*?)&lt;/blockquote&gt;\", html, re.DOTALL)\n\n    for quote in blockquotes:\n        parsed_alert = self._parse_github_alert(quote)\n        if parsed_alert:\n            replacement_macro = self._create_alert_macro(parsed_alert)\n            if replacement_macro:\n                html = html.replace(\n                    f\"&lt;blockquote&gt;{quote}&lt;/blockquote&gt;\", replacement_macro\n                )\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_info_macros","title":"<code>convert_info_macros(html)</code>","text":"<p>Converts html for info, note or warning macros</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_info_macros(self, html: str) -&gt; str:\n    \"\"\"\n    Converts html for info, note or warning macros\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n    # First, convert GitHub-flavored markdown alerts (takes precedence)\n    html = self.convert_github_alerts(html)\n\n    info_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"info\"&gt;&lt;ac:rich-text-body&gt;&lt;p&gt;'\n    # Warning (Yellow Caution Icon) is named 'note' in Confluence\n    warning_tag = info_tag.replace(\"info\", \"note\")\n    # Success (Green Check Icon) is named 'tip' in Confluence\n    success_tag = info_tag.replace(\"info\", \"tip\")\n    # Error (Red Cross Icon) is named 'warning' in Confluence\n    error_tag = info_tag.replace(\"info\", \"warning\")\n    close_tag = \"&lt;/p&gt;&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;&lt;/p&gt;\"\n\n    note_tag = ('&lt;ac:adf-extension&gt;&lt;ac:adf-node type=\"panel\"&gt;'\n                '&lt;ac:adf-attribute key=\"panel-type\"&gt;note&lt;/ac:adf-attribute&gt;'\n                '&lt;ac:adf-content&gt;&lt;p&gt;')\n    note_close = '&lt;/p&gt;&lt;/ac:adf-content&gt;&lt;/ac:adf-node&gt;&lt;/ac:adf-extension&gt;'\n\n    # Custom tags converted into macros\n    html = html.replace(\"&lt;p&gt;~?\", info_tag).replace(\"?~&lt;/p&gt;\", close_tag)\n    html = html.replace(\"&lt;p&gt;~%\", warning_tag).replace(\"%~&lt;/p&gt;\", close_tag)\n    html = html.replace(\"&lt;p&gt;~^\", success_tag).replace(\"^~&lt;/p&gt;\", close_tag)\n    html = html.replace(\"&lt;p&gt;~$\", error_tag).replace(\"$~&lt;/p&gt;\", close_tag)\n\n    html = html.replace(\"&lt;p&gt;~!\", note_tag).replace(\"!~&lt;/p&gt;\", note_close)\n\n    # Convert block quotes into macros\n    quotes = re.findall(\"&lt;blockquote&gt;(.*?)&lt;/blockquote&gt;\", html, re.DOTALL)\n    if quotes:\n        for quote in quotes:\n            note = re.search(\"^&lt;.*&gt;Note\", quote.strip(), re.IGNORECASE)\n            warning = re.search(\"^&lt;.*&gt;Warning\", quote.strip(), re.IGNORECASE)\n            success = re.search(\"^&lt;.*&gt;Success\", quote.strip(), re.IGNORECASE)\n            error = re.search(\"^&lt;.*&gt;Error\", quote.strip(), re.IGNORECASE)\n\n            if note:\n                clean_tag = self.strip_type(quote, \"Note\")\n                macro_tag = (\n                    clean_tag.replace(\"&lt;p&gt;\", note_tag)\n                    .replace(\"&lt;/p&gt;\", note_close)\n                    .strip()\n                )\n            elif warning:\n                clean_tag = self.strip_type(quote, \"Warning\")\n                macro_tag = (\n                    clean_tag.replace(\"&lt;p&gt;\", warning_tag)\n                    .replace(\"&lt;/p&gt;\", close_tag)\n                    .strip()\n                )\n            elif success:\n                clean_tag = self.strip_type(quote, \"Success\")\n                macro_tag = (\n                    clean_tag.replace(\"&lt;p&gt;\", success_tag)\n                    .replace(\"&lt;/p&gt;\", close_tag)\n                    .strip()\n                )\n            elif error:\n                clean_tag = self.strip_type(quote, \"Error\")\n                macro_tag = (\n                    clean_tag.replace(\"&lt;p&gt;\", error_tag)\n                    .replace(\"&lt;/p&gt;\", close_tag)\n                    .strip()\n                )\n            else:\n                macro_tag = (\n                    quote.replace(\"&lt;p&gt;\", info_tag)\n                    .replace(\"&lt;/p&gt;\", close_tag)\n                    .strip()\n                )\n\n            html = html.replace(\"&lt;blockquote&gt;%s&lt;/blockquote&gt;\" % quote, macro_tag)\n\n    # Convert doctoc to toc confluence macro\n    html = self.convert_doctoc(html)\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_md_to_conf_html","title":"<code>convert_md_to_conf_html(has_title=False, remove_emojies=False, add_contents=False)</code>","text":"<p>Convert the Markdown file to Confluence HTML</p> <p>Parameters:</p> Name Type Description Default <code>has_title</code> <code>bool</code> <p>Was a title provided via the CLI?</p> <code>False</code> <code>remove_emojies</code> <code>bool</code> <p>Should emojies be removed?</p> <code>False</code> <code>add_contents</code> <code>bool</code> <p>Should a contents section be added to the page</p> <code>False</code> <p>Returns:</p> Type Description <p>A string representing HTML for the Markdown page</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_md_to_conf_html(\n    self,\n    has_title: bool = False,\n    remove_emojies: bool = False,\n    add_contents: bool = False,\n):\n    \"\"\"\n    Convert the Markdown file to Confluence HTML\n\n    Args:\n        has_title: Was a title provided via the CLI?\n        remove_emojies: Should emojies be removed?\n        add_contents: Should a contents section be added to the page\n\n    Returns:\n        A string representing HTML for the Markdown page\n    \"\"\"\n    html = self.get_html_from_markdown()\n    if not has_title:\n        html = \"\\n\".join(html.split(\"\\n\")[1:])\n\n    LOGGER.debug(\"HTML pre processing\")\n    LOGGER.debug(html)\n    html = self.create_table_of_content(html)\n    html = self.convert_info_macros(html)\n    html = self.convert_comment_block(html)\n    html = self.convert_code_block(html)\n\n    if remove_emojies:\n        html = self.remove_emojies(html)\n\n    if add_contents:\n        html = self.add_contents(html)\n\n    html = self.process_refs(html)\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.create_table_of_content","title":"<code>create_table_of_content(html)</code>","text":"<p>Check for the string '[TOC]' and replaces it the Confluence \"Table of Content\" macro</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def create_table_of_content(self, html: str) -&gt; str:\n    \"\"\"\n    Check for the string '[TOC]' and replaces it the\n    Confluence \"Table of Content\" macro\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    html = str.replace(\n        html,\n        r\"&lt;p&gt;[TOC]&lt;/p&gt;\",\n        '&lt;p&gt;&lt;ac:structured-macro ac:name=\"toc-zone\" ac:schema-version=\"1\" '\n        'data-layout=\"default\"&gt;&lt;ac:rich-text-body&gt;&lt;ac:structured-macro '\n        'ac:name=\"toc\" ac:schema-version=\"1\" data-layout=\"default\"/&gt;'\n        '&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;&lt;/p&gt;',\n    )\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.get_html_from_markdown","title":"<code>get_html_from_markdown()</code>","text":"<p>Convert the Markdown file to HTML.  This is a wrapper around the markdown library</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing HTML for the Markdown page</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def get_html_from_markdown(self) -&gt; str:\n    \"\"\"\n    Convert the Markdown file to HTML.  This is a wrapper\n    around the markdown library\n\n    Returns:\n        A string representing HTML for the Markdown page\n    \"\"\"\n    with codecs.open(self.md_file, \"r\", \"utf-8\") as mdfile:\n        markdown_content = mdfile.read()\n        html = markdown.markdown(\n            markdown_content,\n            extensions=[\n                \"tables\",\n                \"fenced_code\",\n                \"footnotes\",\n                \"mdx_truly_sane_lists\",\n            ],\n        )\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.process_refs","title":"<code>process_refs(html)</code>","text":"<p>Process references</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def process_refs(self, html: str) -&gt; str:\n    \"\"\"\n    Process references\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n    refs = re.findall(r\"\\n(\\[\\^(\\d)\\].*)|&lt;p&gt;(\\[\\^(\\d)\\].*)\", html)\n\n    if refs:\n        for ref in refs:\n            if ref[0]:\n                full_ref = ref[0].replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n                ref_id = ref[1]\n            else:\n                full_ref = ref[2]\n                ref_id = ref[3]\n\n            full_ref = full_ref.replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n            html = html.replace(full_ref, \"\")\n            href = re.search('href=\"(.*?)\"', full_ref).group(1)\n\n            superscript = '&lt;a id=\"test\" href=\"%s\"&gt;&lt;sup&gt;%s&lt;/sup&gt;&lt;/a&gt;' % (\n                href,\n                ref_id,\n            )\n            html = html.replace(\"[^%s]\" % ref_id, superscript)\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.remove_emojies","title":"<code>remove_emojies(html)</code>","text":"<p>Remove emojies if there are any</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def remove_emojies(self, html: str) -&gt; str:\n    \"\"\"\n    Remove emojies if there are any\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    regrex_pattern = re.compile(\n        pattern=\"[\"\n        \"\\U0001f600-\\U0001f64f\"  # emoticons\n        \"\\U0001f300-\\U0001f5ff\"  # symbols &amp; pictographs\n        \"\\U0001f680-\\U0001f6ff\"  # transport &amp; map symbols\n        \"\\U0001f1e0-\\U0001f1ff\"  # flags (iOS)\n        \"]+\",\n        flags=re.UNICODE,\n    )\n    return regrex_pattern.sub(r\"\", html)\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.slug","title":"<code>slug(string, lowercase)</code>","text":"<p>Creates a slug string</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to modify</p> required <code>lowercase</code> <code>bool</code> <p>whether string has to be lowercased</p> required <p>Returns:     slug string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def slug(self, string: str, lowercase: bool) -&gt; str:\n    \"\"\"\n    Creates a slug string\n\n    Args:\n        string: string to modify\n        lowercase: whether string has to be lowercased\n    Returns:\n        slug string\n    \"\"\"\n\n    slug_string = string\n    if lowercase:\n        slug_string = string.lower()\n\n    # Remove all html code tags\n    slug_string = re.sub(r\"&lt;[^&gt;]+&gt;\", \"\", slug_string)\n    # Remove html code like '&amp;amp;'\n    slug_string = re.sub(r\"&amp;[a-z]+;\", \"\", slug_string)\n    # Replace all spaces ( ) with dash (-)\n    slug_string = str.replace(slug_string, \" \", \"-\")\n\n    # Remove all special chars, except for dash (-)\n    slug_string = re.sub(r\"[^a-zA-Z0-9-]\", \"\", slug_string)\n\n    return slug_string\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.strip_type","title":"<code>strip_type(tag, tagtype)</code>","text":"<p>Strips Note or Warning tags from html in various formats</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>tag name</p> required <code>tagtype</code> <code>str</code> <p>tag type</p> required <p>Returns:     modified tag</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def strip_type(self, tag: str, tagtype: str) -&gt; str:\n    \"\"\"\n    Strips Note or Warning tags from html in various formats\n\n    Args:\n        tag: tag name\n        tagtype: tag type\n    Returns:\n        modified tag\n    \"\"\"\n    tag = re.sub(r\"%s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n    tag = re.sub(r\"%s\\s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n    tag = re.sub(r\"&lt;.*?&gt;%s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;.*?&gt;%s\\s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    string_start = re.search(\"&lt;[^&gt;]*&gt;\", tag)\n    tag = self.upper_chars(tag, [string_start.end()])\n    return tag\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.upper_chars","title":"<code>upper_chars(string, indices)</code>","text":"<p>Make characters uppercase in string</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to modify</p> required <code>indices</code> <code>List[int]</code> <p>character indice to change to uppercase</p> required <p>Returns:     uppercased string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def upper_chars(self, string: str, indices: typing.List[int]) -&gt; str:\n    \"\"\"\n    Make characters uppercase in string\n\n    Args:\n        string: string to modify\n        indices: character indice to change to uppercase\n    Returns:\n        uppercased string\n    \"\"\"\n    upper_string = \"\".join(\n        c.upper() if i in indices else c for i, c in enumerate(string)\n    )\n    return upper_string\n</code></pre>"},{"location":"api/main-reference/","title":"md_to_conf","text":""},{"location":"api/main-reference/#md_to_conf.main","title":"<code>main()</code>","text":"<p>Main program</p> Source code in <code>md_to_conf/__init__.py</code> <pre><code>def main():\n    \"\"\"\n    Main program\n\n    \"\"\"\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - \\\n        %(levelname)s - %(funcName)s [%(lineno)d] - \\\n        \\t%(message)s\",\n    )\n    LOGGER = logging.getLogger(__name__)\n\n    # ArgumentParser to parse arguments and options\n    PARSER = get_parser()\n\n    ARGS = PARSER.parse_args()\n\n    # Assign global variables\n    try:\n        # Set log level\n        LOGGER.setLevel(getattr(logging, ARGS.loglevel.upper(), None))\n\n        MARKDOWN_FILE = ARGS.markdownFile\n        SPACE_KEY = ARGS.spacekey\n        USERNAME = os.getenv(\"CONFLUENCE_USERNAME\", ARGS.username)\n        API_KEY = os.getenv(\"CONFLUENCE_API_KEY\", ARGS.apikey)\n        ORGNAME = os.getenv(\"CONFLUENCE_ORGNAME\", ARGS.orgname)\n        ANCESTOR = ARGS.ancestor\n        NOSSL = ARGS.nossl\n        DELETE = ARGS.delete\n        SIMULATE = ARGS.simulate\n        VERSION = ARGS.version\n        MARKDOWN_SOURCE = ARGS.markdownsrc\n        LABELS = ARGS.labels\n        PROPERTIES = dict(ARGS.properties)\n        ATTACHMENTS = ARGS.attachment\n        CONTENTS = ARGS.contents\n        TITLE = ARGS.title\n        REMOVE_EMOJIES = ARGS.remove_emojies\n\n        validate_args(USERNAME, API_KEY, MARKDOWN_FILE, ORGNAME)\n\n    except Exception as err:\n        LOGGER.error(\"\\n\\nException caught:\\n%s \", err)\n        LOGGER.error(\"\\nFailed to process command line arguments. Exiting.\")\n        sys.exit(1)\n\n    LOGGER.info(\"\\t----------------------------------\")\n    LOGGER.info(\"\\tMarkdown to Confluence Upload Tool\")\n    LOGGER.info(\"\\t----------------------------------\")\n\n    LOGGER.info(\"Markdown file:\\t%s\", MARKDOWN_FILE)\n    LOGGER.info(\"Space Key:\\t%s\", SPACE_KEY)\n\n    confluence_converter: ConfluenceConverter = ConfluenceConverter(\n        MARKDOWN_FILE,\n        MARKDOWN_SOURCE,\n        TITLE,\n        ORGNAME,\n        not NOSSL,\n        USERNAME,\n        SPACE_KEY,\n        API_KEY,\n        ANCESTOR,\n        VERSION,\n    )\n\n    confluence_converter.convert(\n        SIMULATE, DELETE, REMOVE_EMOJIES, CONTENTS, LABELS, PROPERTIES, ATTACHMENTS\n    )\n</code></pre>"}]}